{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { watch, ref, provide, h, inject, onUnmounted, onBeforeUnmount, onMounted, nextTick, render as render$3, reactive, computed } from 'vue';\nconst debounce = (fn, time) => {\n  let timeout;\n  return function (...args) {\n    const context = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.apply(context, args);\n      timeout = null;\n    }, time);\n  };\n};\nconst capitalizeFirstLetter = string => {\n  if (!string || typeof string.charAt !== \"function\") {\n    return string;\n  }\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\nconst isFunction = x => typeof x === \"function\";\nconst propsBinder = (methods, leafletElement, props) => {\n  for (const key in props) {\n    const setMethodName = \"set\" + capitalizeFirstLetter(key);\n    if (methods[setMethodName]) {\n      watch(() => props[key], (newVal, oldVal) => {\n        methods[setMethodName](newVal, oldVal);\n      });\n    } else if (leafletElement[setMethodName]) {\n      watch(() => props[key], newVal => {\n        leafletElement[setMethodName](newVal);\n      });\n    }\n  }\n};\nconst propsToLeafletOptions = (propValues, propDefinitions, baseOptions = {}) => {\n  const output = {\n    ...baseOptions\n  };\n  for (const prop in propValues) {\n    const defn = propDefinitions[prop];\n    const val = propValues[prop];\n\n    // Unexpected props should not be converted to Leaflet options.\n    if (!defn) continue;\n    // Custom vue-leaflet props should not be passed to Leaflet.\n    if (defn && defn.custom === true) continue;\n    // Exclude undefined values so that Leaflet uses its own defaults.\n    if (val === undefined) continue;\n    output[prop] = val;\n  }\n  return output;\n};\nconst remapEvents = contextAttrs => {\n  const result = {};\n  for (const attrName in contextAttrs) {\n    if (attrName.startsWith(\"on\") && !attrName.startsWith(\"onUpdate\") && attrName !== \"onReady\") {\n      const eventName = attrName.slice(2).toLocaleLowerCase();\n      result[eventName] = contextAttrs[attrName];\n    }\n  }\n  return result;\n};\nconst resetWebpackIcon = async Icon => {\n  const modules = await Promise.all([import('leaflet/dist/images/marker-icon-2x.png'), import('leaflet/dist/images/marker-icon.png'), import('leaflet/dist/images/marker-shadow.png')]);\n  delete Icon.Default.prototype._getIconUrl;\n  Icon.Default.mergeOptions({\n    iconRetinaUrl: modules[0].default,\n    iconUrl: modules[1].default,\n    shadowUrl: modules[2].default\n  });\n};\n\n/**\n * Wraps a placeholder function and provides it with the given name.\n * The wrapper can later be updated with {@link updateLeafletWrapper}\n * to provide a different function.\n *\n * @param {String} methodName Key used to provide the wrapper function\n */\nconst provideLeafletWrapper = methodName => {\n  const wrapped = ref(() => console.warn(`Method ${methodName} has been invoked without being replaced`));\n  const wrapper = (...args) => wrapped.value(...args);\n  // eslint-disable-next-line vue/no-ref-as-operand\n  wrapper.wrapped = wrapped;\n  provide(methodName, wrapper);\n  return wrapper;\n};\n\n/**\n * Change the function that will be executed when an injected Leaflet wrapper\n * is invoked.\n *\n * @param {*} wrapper Provided wrapper whose wrapped function is to be updated\n * @param {function} leafletMethod New method to be wrapped by the wrapper\n */\nconst updateLeafletWrapper = (wrapper, leafletMethod) => wrapper.wrapped.value = leafletMethod;\nconst WINDOW_OR_GLOBAL = typeof self === \"object\" && self.self === self && self || typeof global === \"object\" && global.global === global && global || undefined;\nconst GLOBAL_LEAFLET_OPT = \"useGlobalLeaflet\";\nconst componentProps = {\n  options: {\n    type: Object,\n    default: () => ({}),\n    custom: true\n  }\n};\nconst setupComponent = props => {\n  return {\n    options: props.options,\n    methods: {}\n  };\n};\nconst layerProps = {\n  ...componentProps,\n  pane: {\n    type: String\n  },\n  attribution: {\n    type: String\n  },\n  name: {\n    type: String,\n    custom: true\n  },\n  layerType: {\n    type: String,\n    custom: true\n  },\n  visible: {\n    type: Boolean,\n    custom: true,\n    default: true\n  }\n};\nconst setupLayer = (props, leafletRef, context) => {\n  const addLayer = inject(\"addLayer\");\n  const removeLayer = inject(\"removeLayer\");\n  const {\n    options: componentOptions,\n    methods: componentMethods\n  } = setupComponent(props);\n  const options = propsToLeafletOptions(props, layerProps, componentOptions);\n  const addThisLayer = () => addLayer({\n    leafletObject: leafletRef.value\n  });\n  const removeThisLayer = () => removeLayer({\n    leafletObject: leafletRef.value\n  });\n  const methods = {\n    ...componentMethods,\n    setAttribution(val, old) {\n      const attributionControl = this.$parent.leafletObject.attributionControl;\n      attributionControl.removeAttribution(old).addAttribution(val);\n    },\n    setName() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setLayerType() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setVisible(isVisible) {\n      if (leafletRef.value) {\n        if (isVisible) {\n          addThisLayer();\n        } else {\n          removeThisLayer();\n        }\n      }\n    },\n    bindPopup({\n      leafletObject\n    }) {\n      if (!leafletRef.value || !isFunction(leafletRef.value.bindPopup)) {\n        console.warn(\"Attempt to bind popup before bindPopup method available on layer.\");\n        return;\n      }\n      leafletRef.value.bindPopup(leafletObject);\n    },\n    bindTooltip({\n      leafletObject\n    }) {\n      if (!leafletRef.value || !isFunction(leafletRef.value.bindTooltip)) {\n        console.warn(\"Attempt to bind tooltip before bindTooltip method available on layer.\");\n        return;\n      }\n      leafletRef.value.bindTooltip(leafletObject);\n    },\n    unbindTooltip() {\n      const tooltip = leafletRef.value && isFunction(leafletRef.value.getTooltip) ? leafletRef.value.getTooltip() : null;\n      if (tooltip && isFunction(tooltip.unbindTooltip)) {\n        tooltip.unbindTooltip();\n      }\n    },\n    unbindPopup() {\n      const popup = leafletRef.value && isFunction(leafletRef.value.getPopup) ? leafletRef.value.getPopup() : null;\n      if (popup && isFunction(popup.unbindPopup)) {\n        popup.unbindPopup();\n      }\n    },\n    updateVisibleProp(value) {\n      /**\n       * Triggers when the visible prop needs to be updated\n       * @type {boolean}\n       * @property {boolean} value - value of the visible property\n       */\n      context.emit(\"update:visible\", value);\n    }\n  };\n  provide(\"bindPopup\", methods.bindPopup);\n  provide(\"bindTooltip\", methods.bindTooltip);\n  provide(\"unbindTooltip\", methods.unbindTooltip);\n  provide(\"unbindPopup\", methods.unbindPopup);\n  onUnmounted(() => {\n    methods.unbindPopup();\n    methods.unbindTooltip();\n    removeThisLayer();\n  });\n  return {\n    options,\n    methods\n  };\n};\nconst render = (ready, slots) => {\n  if (ready && slots.default) {\n    return h(\"div\", {\n      style: {\n        display: \"none\"\n      }\n    }, slots.default());\n  }\n};\nconst interactiveLayerProps = {\n  ...layerProps,\n  interactive: {\n    type: Boolean,\n    default: undefined\n  },\n  bubblingMouseEvents: {\n    type: Boolean,\n    default: undefined\n  }\n};\nconst setupInteractiveLayer = (props, leafletRef, context) => {\n  const {\n    options: layerOptions,\n    methods\n  } = setupLayer(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, interactiveLayerProps, layerOptions);\n  return {\n    options,\n    methods\n  };\n};\nconst pathProps = {\n  ...interactiveLayerProps,\n  stroke: {\n    type: Boolean,\n    default: undefined\n  },\n  color: {\n    type: String\n  },\n  weight: {\n    type: Number\n  },\n  opacity: {\n    type: Number\n  },\n  lineCap: {\n    type: String\n  },\n  lineJoin: {\n    type: String\n  },\n  dashArray: {\n    type: String\n  },\n  dashOffset: {\n    type: String\n  },\n  fill: {\n    type: Boolean,\n    default: undefined\n  },\n  fillColor: {\n    type: String\n  },\n  fillOpacity: {\n    type: Number\n  },\n  fillRule: {\n    type: String\n  },\n  className: {\n    type: String\n  }\n};\nconst setupPath = (props, leafletRef, context) => {\n  const {\n    options: interactiveLayerOptions,\n    methods: interactiveLayerMethods\n  } = setupInteractiveLayer(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, pathProps, interactiveLayerOptions);\n  const removeLayer = inject(\"removeLayer\");\n  const methods = {\n    ...interactiveLayerMethods,\n    setStroke(stroke) {\n      leafletRef.value.setStyle({\n        stroke\n      });\n    },\n    setColor(color) {\n      leafletRef.value.setStyle({\n        color\n      });\n    },\n    setWeight(weight) {\n      leafletRef.value.setStyle({\n        weight\n      });\n    },\n    setOpacity(opacity) {\n      leafletRef.value.setStyle({\n        opacity\n      });\n    },\n    setLineCap(lineCap) {\n      leafletRef.value.setStyle({\n        lineCap\n      });\n    },\n    setLineJoin(lineJoin) {\n      leafletRef.value.setStyle({\n        lineJoin\n      });\n    },\n    setDashArray(dashArray) {\n      leafletRef.value.setStyle({\n        dashArray\n      });\n    },\n    setDashOffset(dashOffset) {\n      leafletRef.value.setStyle({\n        dashOffset\n      });\n    },\n    setFill(fill) {\n      leafletRef.value.setStyle({\n        fill\n      });\n    },\n    setFillColor(fillColor) {\n      leafletRef.value.setStyle({\n        fillColor\n      });\n    },\n    setFillOpacity(fillOpacity) {\n      leafletRef.value.setStyle({\n        fillOpacity\n      });\n    },\n    setFillRule(fillRule) {\n      leafletRef.value.setStyle({\n        fillRule\n      });\n    },\n    setClassName(className) {\n      leafletRef.value.setStyle({\n        className\n      });\n    }\n  };\n  onBeforeUnmount(() => {\n    removeLayer({\n      leafletObject: leafletRef.value\n    });\n  });\n  return {\n    options,\n    methods\n  };\n};\nconst circleMarkerProps = {\n  ...pathProps,\n  /**\n   * Radius of the marker in pixels.\n   */\n  radius: {\n    type: Number\n  },\n  latLng: {\n    type: [Object, Array],\n    required: true,\n    custom: true\n  }\n};\nconst setupCircleMarker = (props, leafletRef, context) => {\n  const {\n    options: pathOptions,\n    methods: pathMethods\n  } = setupPath(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, circleMarkerProps, pathOptions);\n  const methods = {\n    ...pathMethods,\n    setRadius(radius) {\n      leafletRef.value.setRadius(radius);\n    },\n    setLatLng(latLng) {\n      leafletRef.value.setLatLng(latLng);\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\nconst circleProps = {\n  ...circleMarkerProps,\n  /**\n   * Radius of the circle in meters.\n   */\n  radius: {\n    type: Number\n  }\n};\nconst setupCircle = (props, leafletRef, context) => {\n  const {\n    options: circleMarkerOptions,\n    methods: circleMarkerMethods\n  } = setupCircleMarker(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, circleProps, circleMarkerOptions);\n  const methods = {\n    ...circleMarkerMethods\n  };\n  return {\n    options,\n    methods\n  };\n};\n\n/**\n * Circle component, lets you add and personalize circles on the map\n */\nvar script = {\n  name: \"LCircle\",\n  props: circleProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      options,\n      methods\n    } = setupCircle(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        circle,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = circle(props.latLng, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript.__file = \"src/components/LCircle.vue\";\n\n/**\n * Circle Marker component, lets you add and personalize circle markers on the map\n */\nvar script$1 = {\n  name: \"LCircleMarker\",\n  props: circleMarkerProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      options,\n      methods\n    } = setupCircleMarker(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        circleMarker,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = circleMarker(props.latLng, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript$1.__file = \"src/components/LCircleMarker.vue\";\nconst controlProps = {\n  ...componentProps,\n  position: {\n    type: String\n  }\n};\nconst setupControl = (props, leafletRef) => {\n  const {\n    options: componentOptions,\n    methods: componentMethods\n  } = setupComponent(props);\n  const options = propsToLeafletOptions(props, controlProps, componentOptions);\n  const methods = {\n    ...componentMethods,\n    setPosition(position) {\n      if (leafletRef.value) {\n        leafletRef.value.setPosition(position);\n      }\n    }\n  };\n  onUnmounted(() => {\n    if (leafletRef.value) {\n      leafletRef.value.remove();\n    }\n  });\n  return {\n    options,\n    methods\n  };\n};\nconst render$1 = slots => {\n  if (slots.default) {\n    return h(\"div\", {\n      ref: \"root\"\n    }, slots.default());\n  }\n  return null;\n};\nvar script$2 = {\n  name: \"LControl\",\n  props: {\n    ...controlProps,\n    disableClickPropagation: {\n      type: Boolean,\n      custom: true,\n      default: true\n    },\n    disableScrollPropagation: {\n      type: Boolean,\n      custom: true,\n      default: false\n    }\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n    const {\n      options,\n      methods\n    } = setupControl(props, leafletRef);\n    onMounted(async () => {\n      const {\n        Control,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      const LControl = Control.extend({\n        onAdd() {\n          return root.value;\n        }\n      });\n      leafletRef.value = new LControl(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({\n        leafletObject: leafletRef.value\n      });\n      if (props.disableClickPropagation) {\n        DomEvent.disableClickPropagation(root.value);\n      }\n      if (props.disableScrollPropagation) {\n        DomEvent.disableScrollPropagation(root.value);\n      }\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      root,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render$1(this.$slots);\n  }\n};\nscript$2.__file = \"src/components/LControl.vue\";\nconst controlAttributionProps = {\n  ...controlProps,\n  prefix: {\n    type: String\n  }\n};\nconst setupControlAttribution = (props, leafletRef) => {\n  const {\n    options: controlOptions,\n    methods: controlMethods\n  } = setupControl(props, leafletRef);\n  const options = propsToLeafletOptions(props, controlAttributionProps, controlOptions);\n  const methods = {\n    ...controlMethods,\n    setPrefix(prefix) {\n      leafletRef.value.setPrefix(prefix);\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\nvar script$3 = {\n  name: \"LControlAttribution\",\n  props: controlAttributionProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n    const {\n      options,\n      methods\n    } = setupControlAttribution(props, leafletRef);\n    onMounted(async () => {\n      const {\n        control\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = control.attribution(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({\n        leafletObject: leafletRef.value\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      leafletObject: leafletRef.value\n    };\n  },\n  render() {\n    return null;\n  }\n};\nscript$3.__file = \"src/components/LControlAttribution.vue\";\nconst controlLayersProps = {\n  ...controlProps,\n  collapsed: {\n    type: Boolean,\n    default: undefined\n  },\n  autoZIndex: {\n    type: Boolean,\n    default: undefined\n  },\n  hideSingleBase: {\n    type: Boolean,\n    default: undefined\n  },\n  sortLayers: {\n    type: Boolean,\n    default: undefined\n  },\n  sortFunction: {\n    type: Function\n  }\n};\nconst setupControlLayers = (props, leafletRef) => {\n  const {\n    options: controlOptions\n  } = setupControl(props, leafletRef);\n  const options = propsToLeafletOptions(props, controlLayersProps, controlOptions);\n  const methods = {\n    addLayer(layer) {\n      if (layer.layerType === \"base\") {\n        leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);\n      } else if (layer.layerType === \"overlay\") {\n        leafletRef.value.addOverlay(layer.leafletObject, layer.name);\n      }\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\nvar script$4 = {\n  name: \"LControlLayers\",\n  props: controlLayersProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerLayerControl = inject(\"registerLayerControl\");\n    const {\n      options,\n      methods\n    } = setupControlLayers(props, leafletRef);\n    onMounted(async () => {\n      const {\n        control\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = control.layers(null, null, options);\n      propsBinder(methods, leafletRef.value, props);\n      registerLayerControl({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      leafletObject: leafletRef.value\n    };\n  },\n  render() {\n    return null;\n  }\n};\nscript$4.__file = \"src/components/LControlLayers.vue\";\nconst controlScaleProps = {\n  ...controlProps,\n  maxWidth: {\n    type: Number\n  },\n  metric: {\n    type: Boolean,\n    default: undefined\n  },\n  imperial: {\n    type: Boolean,\n    default: undefined\n  },\n  updateWhenIdle: {\n    type: Boolean,\n    default: undefined\n  }\n};\nconst setupControlScale = (props, leafletRef) => {\n  const {\n    options: controlOptions,\n    methods: controlMethods\n  } = setupControl(props, leafletRef);\n  const options = propsToLeafletOptions(props, controlScaleProps, controlOptions);\n  return {\n    options,\n    methods: controlMethods\n  };\n};\nvar script$5 = {\n  name: \"LControlScale\",\n  props: controlScaleProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n    const {\n      options,\n      methods\n    } = setupControlScale(props, leafletRef);\n    onMounted(async () => {\n      const {\n        control\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = control.scale(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({\n        leafletObject: leafletRef.value\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      leafletObject: leafletRef.value\n    };\n  },\n  render() {\n    return null;\n  }\n};\nscript$5.__file = \"src/components/LControlScale.vue\";\nconst controlZoomProps = {\n  ...controlProps,\n  zoomInText: {\n    type: String\n  },\n  zoomInTitle: {\n    type: String\n  },\n  zoomOutText: {\n    type: String\n  },\n  zoomOutTitle: {\n    type: String\n  }\n};\nconst setupControlZoom = (props, leafletRef) => {\n  const {\n    options: controlOptions,\n    methods: controlMethods\n  } = setupControl(props, leafletRef);\n  const options = propsToLeafletOptions(props, controlZoomProps, controlOptions);\n  return {\n    options,\n    methods: controlMethods\n  };\n};\nvar script$6 = {\n  name: \"LControlZoom\",\n  props: controlZoomProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n    const {\n      options,\n      methods\n    } = setupControlZoom(props, leafletRef);\n    onMounted(async () => {\n      const {\n        control\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = control.zoom(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({\n        leafletObject: leafletRef.value\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      leafletObject: leafletRef.value\n    };\n  },\n  render() {\n    return null;\n  }\n};\nscript$6.__file = \"src/components/LControlZoom.vue\";\nconst layerGroupProps = {\n  ...layerProps\n};\nconst setupLayerGroup = (props, leafletRef, context) => {\n  const {\n    options: layerOptions,\n    methods: layerMethods\n  } = setupLayer(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, layerGroupProps, layerOptions);\n  const methods = {\n    ...layerMethods,\n    addLayer(layer) {\n      leafletRef.value.addLayer(layer.leafletObject);\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    }\n  };\n  provide(\"addLayer\", methods.addLayer);\n  provide(\"removeLayer\", methods.removeLayer);\n  return {\n    options,\n    methods\n  };\n};\nconst featureGroupProps = {\n  ...layerGroupProps\n};\nconst setupFeatureGroup = (props, leafletRef) => {\n  const {\n    options: layerOptions,\n    methods: layerGroupMethods\n  } = setupLayerGroup(props, leafletRef);\n  const options = propsToLeafletOptions(props, featureGroupProps, layerOptions);\n  const methods = {\n    ...layerGroupMethods\n  };\n  return {\n    options,\n    methods\n  };\n};\nvar script$7 = {\n  props: featureGroupProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      methods,\n      options\n    } = setupFeatureGroup(props, leafletRef);\n    onMounted(async () => {\n      const {\n        featureGroup,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = featureGroup(options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript$7.__file = \"src/components/LFeatureGroup.vue\";\nconst geoJSONProps = {\n  ...layerGroupProps,\n  geojson: {\n    type: [Object, Array],\n    custom: true\n  }\n};\nconst setupGeoJSON = (props, leafletRef, context) => {\n  const {\n    options: layerOptions,\n    methods: layerGroupMethods\n  } = setupLayerGroup(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, geoJSONProps, layerOptions);\n  const methods = {\n    ...layerGroupMethods,\n    setGeojson(newVal) {\n      leafletRef.value.clearLayers();\n      leafletRef.value.addData(newVal);\n    },\n    getGeoJSONData() {\n      return leafletRef.value.toGeoJSON();\n    },\n    getBounds() {\n      return leafletRef.value.getBounds();\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\nvar script$8 = {\n  props: geoJSONProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      methods,\n      options\n    } = setupGeoJSON(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        geoJSON,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = geoJSON(props.geojson, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript$8.__file = \"src/components/LGeoJson.vue\";\nconst gridLayerProps = {\n  ...layerProps,\n  opacity: {\n    type: Number\n  },\n  zIndex: {\n    type: Number\n  },\n  tileSize: {\n    type: Number\n  },\n  noWrap: {\n    type: Boolean,\n    default: undefined\n  },\n  minZoom: {\n    type: Number\n  },\n  maxZoom: {\n    type: Number\n  }\n};\nconst setupGridLayer = (props, leafletRef, context) => {\n  const {\n    options: layerOptions,\n    methods: layerMethods\n  } = setupLayer(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, gridLayerProps, layerOptions);\n  return {\n    options,\n    methods: {\n      ...layerMethods\n    }\n  };\n};\nvar script$9 = {\n  props: {\n    ...gridLayerProps,\n    childRender: {\n      type: Function,\n      required: true\n    }\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const tileComponents = ref({});\n    const root = ref(null);\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      options,\n      methods\n    } = setupGridLayer(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        GridLayer,\n        DomEvent,\n        DomUtil\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      methods.onUnload = e => {\n        const key = leafletRef.value._tileCoordsToKey(e.coords);\n        if (tileComponents[key]) {\n          tileComponents[key].innerHTML = \"\";\n          tileComponents[key] = undefined;\n        }\n      };\n      methods.setTileComponent = () => {\n        leafletRef.value.redraw();\n      };\n      const GLayer = GridLayer.extend({\n        createTile(coords) {\n          const key = leafletRef.value._tileCoordsToKey(coords);\n          tileComponents[key] = DomUtil.create(\"div\");\n          let vNode = h({\n            setup: props.childRender,\n            props: [\"coords\"]\n          }, {\n            coords\n          });\n          render$3(vNode, tileComponents[key]);\n          return tileComponents[key];\n        }\n      });\n      leafletRef.value = new GLayer(options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.on(\"tileunload\", methods.onUnload);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    onUnmounted(() => {\n      leafletRef.value.off(\"tileunload\", methods.onUnload);\n    });\n    return {\n      root,\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    if (this.ready) {\n      return h(\"div\", {\n        style: {\n          display: \"none\"\n        },\n        ref: \"root\"\n      });\n    }\n    return null;\n  }\n};\nscript$9.__file = \"src/components/LGridLayer.vue\";\nconst iconProps = {\n  iconUrl: {\n    type: String\n  },\n  iconRetinaUrl: {\n    type: String\n  },\n  iconSize: {\n    type: [Object, Array]\n  },\n  iconAnchor: {\n    type: [Object, Array]\n  },\n  popupAnchor: {\n    type: [Object, Array]\n  },\n  tooltipAnchor: {\n    type: [Object, Array]\n  },\n  shadowUrl: {\n    type: String\n  },\n  shadowRetinaUrl: {\n    type: String\n  },\n  shadowSize: {\n    type: [Object, Array]\n  },\n  shadowAnchor: {\n    type: [Object, Array]\n  },\n  bgPos: {\n    type: [Object, Array]\n  },\n  className: {\n    type: String\n  }\n};\n\n/**\n * Icon component, lets you add and custom icons to the map\n */\nvar script$a = {\n  name: \"LIcon\",\n  props: {\n    ...iconProps,\n    ...componentProps\n  },\n  setup(props, context) {\n    const root = ref(null);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const canSetParentHtml = inject(\"canSetParentHtml\");\n    const setParentHtml = inject(\"setParentHtml\");\n    const setIcon = inject(\"setIcon\");\n    let onDomEvent;\n    let offDomEvent;\n    let divIcon;\n    let icon;\n    let iconObject = undefined;\n    const createIcon = (el, recreationNeeded, htmlSwapNeeded) => {\n      const elHtml = el && el.innerHTML;\n      if (!recreationNeeded) {\n        if (htmlSwapNeeded && iconObject && canSetParentHtml()) {\n          setParentHtml(elHtml);\n        }\n        return;\n      }\n      const listeners = remapEvents(context.attrs);\n      if (iconObject) {\n        offDomEvent(iconObject, listeners);\n      }\n      const {\n        options: componentOptions\n      } = setupComponent(props);\n      const options = propsToLeafletOptions(props, iconProps, componentOptions);\n      if (elHtml) {\n        options.html = elHtml;\n      }\n      iconObject = options.html ? divIcon(options) : icon(options);\n      onDomEvent(iconObject, listeners);\n      setIcon(iconObject);\n    };\n    const scheduleCreateIcon = () => {\n      nextTick(() => createIcon(root.value, true, false));\n    };\n    const scheduleHtmlSwap = () => {\n      nextTick(() => createIcon(root.value, false, true));\n    };\n    const methods = {\n      setIconUrl: scheduleCreateIcon,\n      setIconRetinaUrl: scheduleCreateIcon,\n      setIconSize: scheduleCreateIcon,\n      setIconAnchor: scheduleCreateIcon,\n      setPopupAnchor: scheduleCreateIcon,\n      setTooltipAnchor: scheduleCreateIcon,\n      setShadowUrl: scheduleCreateIcon,\n      setShadowRetinaUrl: scheduleCreateIcon,\n      setShadowAnchor: scheduleCreateIcon,\n      setBgPos: scheduleCreateIcon,\n      setClassName: scheduleCreateIcon,\n      setHtml: scheduleCreateIcon\n    };\n    onMounted(async () => {\n      const {\n        DomEvent,\n        divIcon: lDivIcon,\n        icon: lIcon\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      onDomEvent = DomEvent.on;\n      offDomEvent = DomEvent.off;\n      divIcon = lDivIcon;\n      icon = lIcon;\n      propsBinder(methods, {}, props);\n      const observer = new MutationObserver(scheduleHtmlSwap);\n      observer.observe(root.value, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n      scheduleCreateIcon();\n    });\n    return {\n      root\n    };\n  },\n  render() {\n    const content = this.$slots.default ? this.$slots.default() : undefined;\n    return h(\"div\", {\n      ref: \"root\"\n    }, content);\n  }\n};\nscript$a.__file = \"src/components/LIcon.vue\";\n\n/**\n * @typedef {import('leaflet/dist/leaflet-src.esm.js').LatLngBounds} LatLngBounds\n */\n\nconst imageOverlayProps = {\n  ...layerProps,\n  opacity: {\n    type: Number\n  },\n  alt: {\n    type: String\n  },\n  interactive: {\n    type: Boolean,\n    default: undefined\n  },\n  crossOrigin: {\n    type: Boolean,\n    default: undefined\n  },\n  errorOverlayUrl: {\n    type: String\n  },\n  zIndex: {\n    type: Number\n  },\n  className: {\n    type: String\n  },\n  url: {\n    type: String,\n    required: true,\n    custom: true\n  },\n  bounds: {\n    type: [Array, Object],\n    required: true,\n    custom: true\n  }\n};\nconst setupImageOverlay = (props, leafletRef, context) => {\n  const {\n    options: layerOptions,\n    methods: layerMethods\n  } = setupLayer(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, imageOverlayProps, layerOptions);\n  const methods = {\n    ...layerMethods,\n    /**\n     * Sets the opacity of the overlay.\n     * @param {number} opacity\n     */\n    setOpacity(opacity) {\n      return leafletRef.value.setOpacity(opacity);\n    },\n    /**\n     * Changes the URL of the image.\n     * @param {string} url\n     */\n    setUrl(url) {\n      return leafletRef.value.setUrl(url);\n    },\n    /**\n     * Update the bounds that this ImageOverlay covers\n     * @param {LatLngBounds | Array<Array<number>>} bounds\n     */\n    setBounds(bounds) {\n      return leafletRef.value.setBounds(bounds);\n    },\n    /**\n     * Get the bounds that this ImageOverlay covers\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n      return leafletRef.value.getBounds();\n    },\n    /**\n     * Returns the instance of HTMLImageElement used by this overlay.\n     * @returns {HTMLElement}\n     */\n    getElement() {\n      return leafletRef.value.getElement();\n    },\n    /**\n     * Brings the layer to the top of all overlays.\n     */\n    bringToFront() {\n      return leafletRef.value.bringToFront();\n    },\n    /**\n     * Brings the layer to the bottom of all overlays.\n     */\n    bringToBack() {\n      return leafletRef.value.bringToBack();\n    },\n    /**\n     * Changes the zIndex of the image overlay.\n     * @param {number} zIndex\n     */\n    setZIndex(zIndex) {\n      return leafletRef.value.setZIndex(zIndex);\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\n\n/**\n * ImageOverlay component, render a plain image instead of a geospatial map.\n */\nvar script$b = {\n  name: \"LImageOverlay\",\n  props: imageOverlayProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      options,\n      methods\n    } = setupImageOverlay(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        imageOverlay,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = imageOverlay(props.url, props.bounds, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript$b.__file = \"src/components/LImageOverlay.vue\";\nvar script$c = {\n  props: layerGroupProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      methods\n    } = setupLayerGroup(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        layerGroup,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = layerGroup(props.options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript$c.__file = \"src/components/LLayerGroup.vue\";\nconst mapProps = {\n  ...componentProps,\n  /**\n   * The center of the map, supports .sync modifier\n   */\n  center: {\n    type: [Object, Array]\n  },\n  /**\n   * The bounds of the map, supports .sync modifier\n   */\n  bounds: {\n    type: [Array, Object]\n  },\n  /**\n   * The max bounds of the map\n   */\n  maxBounds: {\n    type: [Array, Object]\n  },\n  /**\n   * The zoom of the map, supports .sync modifier\n   */\n  zoom: {\n    type: Number\n  },\n  /**\n   * The minZoom of the map\n   */\n  minZoom: {\n    type: Number\n  },\n  /**\n   * The maxZoom of the map\n   */\n  maxZoom: {\n    type: Number\n  },\n  /**\n   * The paddingBottomRight of the map\n   */\n  paddingBottomRight: {\n    type: Array\n  },\n  /**\n   * The paddingTopLeft of the map\n   */\n  paddingTopLeft: {\n    type: Array\n  },\n  /**\n   * The padding of the map\n   */\n  padding: {\n    type: Array\n  },\n  /**\n   * The worldCopyJump option for the map\n   */\n  worldCopyJump: {\n    type: Boolean,\n    default: undefined\n  },\n  /**\n   * The CRS to use for the map. Can be an object that defines a coordinate reference\n   * system for projecting geographical points into screen coordinates and back\n   * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string\n   * name identifying one of Leaflet's defined CRSs, such as \"EPSG4326\".\n   */\n  crs: {\n    type: [String, Object]\n  },\n  maxBoundsViscosity: {\n    type: Number\n  },\n  inertia: {\n    type: Boolean,\n    default: undefined\n  },\n  inertiaDeceleration: {\n    type: Number\n  },\n  inertiaMaxSpeed: {\n    type: Number\n  },\n  easeLinearity: {\n    type: Number\n  },\n  zoomAnimation: {\n    type: Boolean,\n    default: undefined\n  },\n  zoomAnimationThreshold: {\n    type: Number\n  },\n  fadeAnimation: {\n    type: Boolean,\n    default: undefined\n  },\n  markerZoomAnimation: {\n    type: Boolean,\n    default: undefined\n  },\n  noBlockingAnimations: {\n    type: Boolean,\n    default: undefined\n  },\n  useGlobalLeaflet: {\n    type: Boolean,\n    default: undefined\n  }\n};\nvar script$d = {\n  emits: [\"ready\", \"update:zoom\", \"update:center\", \"update:bounds\"],\n  props: mapProps,\n  setup(props, context) {\n    const root = ref(null);\n    const blueprint = reactive({\n      ready: false,\n      leafletRef: {},\n      layersToAdd: [],\n      layersInControl: []\n    });\n    const {\n      options: componentOptions\n    } = setupComponent(props);\n    const options = propsToLeafletOptions(props, mapProps, componentOptions);\n    const addLayer = provideLeafletWrapper(\"addLayer\");\n    const removeLayer = provideLeafletWrapper(\"removeLayer\");\n    const registerControl = provideLeafletWrapper(\"registerControl\");\n    const registerLayerControl = provideLeafletWrapper(\"registerLayerControl\");\n    provide(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);\n    const eventHandlers = {\n      moveEndHandler() {\n        /**\n         * Triggers when zoom is updated\n         * @type {number,string}\n         */\n        context.emit(\"update:zoom\", blueprint.leafletRef.getZoom());\n        /**\n         * Triggers when center is updated\n         * @type {object,array}\n         */\n        context.emit(\"update:center\", blueprint.leafletRef.getCenter());\n\n        /**\n         * Triggers when bounds are updated\n         * @type {object}\n         */\n        context.emit(\"update:bounds\", blueprint.leafletRef.getBounds());\n      },\n      overlayAddHandler(e) {\n        const layer = blueprint.layersInControl.find(l => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(true);\n        }\n      },\n      overlayRemoveHandler(e) {\n        const layer = blueprint.layersInControl.find(l => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(false);\n        }\n      }\n    };\n    onMounted(async () => {\n      if (props.useGlobalLeaflet) {\n        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await import('leaflet'));\n      }\n      const {\n        map,\n        CRS,\n        Icon,\n        latLngBounds,\n        latLng,\n        DomEvent\n      } = props.useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      try {\n        options.beforeMapMount && (await options.beforeMapMount());\n      } catch (error) {\n        console.error(`The following error occurred running the provided beforeMapMount hook ${error.message}`);\n      }\n      await resetWebpackIcon(Icon);\n      const optionsCrs = typeof options.crs == \"string\" ? CRS[options.crs] : options.crs;\n      options.crs = optionsCrs || CRS.EPSG3857;\n      const methods = {\n        addLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd.push(layer);\n            } else {\n              const exist = blueprint.layersInControl.find(l => l.leafletObject._leaflet_id === layer.leafletObject._leaflet_id);\n              if (!exist) {\n                blueprint.layerControl.addLayer(layer);\n                blueprint.layersInControl.push(layer);\n              }\n            }\n          }\n          if (layer.visible !== false) {\n            blueprint.leafletRef.addLayer(layer.leafletObject);\n          }\n        },\n        removeLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd = blueprint.layersToAdd.filter(l => l.name !== layer.name);\n            } else {\n              blueprint.layerControl.removeLayer(layer.leafletObject);\n              blueprint.layersInControl = blueprint.layersInControl.filter(l => l.leafletObject._leaflet_id !== layer.leafletObject._leaflet_id);\n            }\n          }\n          blueprint.leafletRef.removeLayer(layer.leafletObject);\n        },\n        registerLayerControl(lControlLayer) {\n          blueprint.layerControl = lControlLayer;\n          blueprint.layersToAdd.forEach(layer => {\n            blueprint.layerControl.addLayer(layer);\n          });\n          blueprint.layersToAdd = [];\n          registerControl(lControlLayer);\n        },\n        registerControl(lControl) {\n          blueprint.leafletRef.addControl(lControl.leafletObject);\n        },\n        setZoom(newVal) {\n          const zoom = blueprint.leafletRef.getZoom();\n          if (newVal !== zoom) {\n            blueprint.leafletRef.setZoom(newVal, {\n              animate: props.noBlockingAnimations ? false : null\n            });\n          }\n        },\n        setPaddingBottomRight(newVal) {\n          blueprint.paddingBottomRight = newVal;\n        },\n        setPaddingTopLeft(newVal) {\n          blueprint.paddingTopLeft = newVal;\n        },\n        setPadding(newVal) {\n          blueprint.padding = newVal;\n        },\n        setCrs(newVal) {\n          const prevBounds = blueprint.leafletRef.getBounds();\n          blueprint.leafletRef.options.crs = newVal;\n          blueprint.leafletRef.fitBounds(prevBounds, {\n            animate: false,\n            padding: [0, 0]\n          });\n        },\n        fitBounds(bounds) {\n          blueprint.leafletRef.fitBounds(bounds, {\n            animate: this.noBlockingAnimations ? false : null\n          });\n        },\n        setBounds(newVal) {\n          if (!newVal) {\n            return;\n          }\n          const newBounds = latLngBounds(newVal);\n          if (!newBounds.isValid()) {\n            return;\n          }\n          const oldBounds = blueprint.lastSetBounds || blueprint.leafletRef.getBounds();\n          const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals\n          if (boundsChanged) {\n            blueprint.lastSetBounds = newBounds;\n            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);\n          }\n        },\n        setCenter(newVal) {\n          if (newVal == null) {\n            return;\n          }\n          const newCenter = latLng(newVal);\n          const oldCenter = blueprint.lastSetCenter || blueprint.leafletRef.getCenter();\n          if (oldCenter.lat !== newCenter.lat || oldCenter.lng !== newCenter.lng) {\n            blueprint.lastSetCenter = newCenter;\n            blueprint.leafletRef.panTo(newCenter, {\n              animate: this.noBlockingAnimations ? false : null\n            });\n          }\n        }\n      };\n      updateLeafletWrapper(addLayer, methods.addLayer);\n      updateLeafletWrapper(removeLayer, methods.removeLayer);\n      updateLeafletWrapper(registerControl, methods.registerControl);\n      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);\n      blueprint.leafletRef = map(root.value, options);\n      propsBinder(methods, blueprint.leafletRef, props);\n      const listeners = remapEvents(context.attrs);\n      blueprint.leafletRef.on(\"moveend\", debounce(eventHandlers.moveEndHandler, 100));\n      blueprint.leafletRef.on(\"overlayadd\", eventHandlers.overlayAddHandler);\n      blueprint.leafletRef.on(\"overlayremove\", eventHandlers.overlayRemoveHandler);\n      DomEvent.on(blueprint.leafletRef, listeners);\n      blueprint.ready = true;\n      nextTick(() => context.emit(\"ready\", blueprint.leafletRef));\n    });\n    onBeforeUnmount(() => {\n      if (blueprint.leafletRef) {\n        blueprint.leafletRef.off();\n        blueprint.leafletRef.remove();\n      }\n    });\n    const leafletObject = computed(() => blueprint.leafletRef);\n    const ready = computed(() => blueprint.ready);\n    return {\n      root,\n      ready,\n      leafletObject\n    };\n  },\n  render() {\n    return h(\"div\", {\n      style: {\n        width: \"100%\",\n        height: \"100%\"\n      },\n      ref: \"root\"\n    }, this.ready ? this.$slots.default() : {});\n  }\n};\nscript$d.__file = \"src/components/LMap.vue\";\nconst markerProps = {\n  ...layerProps,\n  draggable: {\n    type: Boolean,\n    default: undefined\n  },\n  icon: {\n    type: [Object]\n  },\n  zIndexOffset: {\n    type: Number\n  },\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    required: true\n  }\n};\nconst setupMarker = (props, leafletRef, context) => {\n  const {\n    options: layerOptions,\n    methods: layerMethods\n  } = setupLayer(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, markerProps, layerOptions);\n  const methods = {\n    ...layerMethods,\n    setDraggable(value) {\n      if (leafletRef.value.dragging) {\n        value ? leafletRef.value.dragging.enable() : leafletRef.value.dragging.disable();\n      }\n    },\n    latLngSync(event) {\n      context.emit(\"update:latLng\", event.latlng);\n      context.emit(\"update:lat-lng\", event.latlng);\n    },\n    setLatLng(newVal) {\n      if (newVal == null) {\n        return;\n      }\n      if (leafletRef.value) {\n        const oldLatLng = leafletRef.value.getLatLng();\n        if (!oldLatLng || !oldLatLng.equals(newVal)) {\n          leafletRef.value.setLatLng(newVal);\n        }\n      }\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\n\n/**\n * Marker component, lets you add and personalize markers on the map\n */\nvar script$e = {\n  name: \"LMarker\",\n  props: markerProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    provide(\"canSetParentHtml\", () => !!leafletRef.value.getElement());\n    provide(\"setParentHtml\", html => leafletRef.value.getElement().innerHTML = html);\n    provide(\"setIcon\", newIcon => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon));\n    const {\n      options,\n      methods\n    } = setupMarker(props, leafletRef, context);\n    if (options.icon === undefined) {\n      // If the options object has a property named 'icon', then Leaflet will overwrite\n      // the default icon with it for the marker, _even if it is undefined_.\n      // This leads to the issue discussed in https://github.com/vue-leaflet/vue-leaflet/issues/130\n      delete options.icon;\n    }\n    onMounted(async () => {\n      const {\n        marker,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = marker(props.latLng, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.on(\"move\", debounce(methods.latLngSync, 100));\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript$e.__file = \"src/components/LMarker.vue\";\nconst polylineProps = {\n  ...pathProps,\n  smoothFactor: {\n    type: Number\n  },\n  noClip: {\n    type: Boolean,\n    default: undefined\n  },\n  latLngs: {\n    type: Array,\n    required: true,\n    custom: true\n  }\n};\nconst setupPolyline = (props, leafletRef, context) => {\n  const {\n    options: pathOptions,\n    methods: pathMethods\n  } = setupPath(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, polylineProps, pathOptions);\n  const methods = {\n    ...pathMethods,\n    setSmoothFactor(smoothFactor) {\n      leafletRef.value.setStyle({\n        smoothFactor\n      });\n    },\n    setNoClip(noClip) {\n      leafletRef.value.setStyle({\n        noClip\n      });\n    },\n    addLatLng(latLng) {\n      leafletRef.value.addLatLng(latLng);\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\nconst polygonProps = {\n  ...polylineProps\n};\nconst setupPolygon = (props, leafletRef, context) => {\n  const {\n    options: polylineOptions,\n    methods: polylineMethods\n  } = setupPolyline(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, polygonProps, polylineOptions);\n  const methods = {\n    ...polylineMethods,\n    toGeoJSON(precision) {\n      return leafletRef.value.toGeoJSON(precision);\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\n\n/**\n * Polygon component, lets you add and customize polygon regions on the map\n */\nvar script$f = {\n  name: \"LPolygon\",\n  props: polygonProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      options,\n      methods\n    } = setupPolygon(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        polygon,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = polygon(props.latLngs, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript$f.__file = \"src/components/LPolygon.vue\";\n\n/**\n * Polyline component, lets you add and personalize polylines on the map\n */\nvar script$g = {\n  name: \"LPolyline\",\n  props: polylineProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      options,\n      methods\n    } = setupPolyline(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        polyline,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = polyline(props.latLngs, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript$g.__file = \"src/components/LPolyline.vue\";\nconst popperProps = {\n  ...componentProps,\n  content: {\n    type: String,\n    default: null\n  }\n};\nconst setupPopper = (props, leafletRef) => {\n  const {\n    options,\n    methods: componentMethods\n  } = setupComponent(props);\n  const methods = {\n    ...componentMethods,\n    setContent(newVal) {\n      if (leafletRef.value && newVal !== null && newVal !== undefined) {\n        leafletRef.value.setContent(newVal);\n      }\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\nconst render$2 = slots => {\n  if (slots.default) {\n    return h(\"div\", {\n      ref: \"root\"\n    }, slots.default());\n  }\n  return null;\n};\nconst popupProps = {\n  ...popperProps,\n  latLng: {\n    type: [Object, Array],\n    default: () => []\n  }\n};\nconst setupPopup = (props, leafletRef) => {\n  const {\n    options,\n    methods\n  } = setupPopper(props, leafletRef);\n  const unbindPopup = inject(\"unbindPopup\");\n  onBeforeUnmount(() => {\n    unbindPopup();\n  });\n  return {\n    options,\n    methods\n  };\n};\n\n/**\n * Display a popup on the map\n */\nvar script$h = {\n  name: \"LPopup\",\n  props: popupProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindPopup = inject(\"bindPopup\");\n    const {\n      options,\n      methods\n    } = setupPopup(props, leafletRef);\n    onMounted(async () => {\n      const {\n        popup,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = popup(options);\n      if (props.latLng !== undefined) {\n        leafletRef.value.setLatLng(props.latLng);\n      }\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindPopup({\n        leafletObject: leafletRef.value\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      root,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render$2(this.$slots);\n  }\n};\nscript$h.__file = \"src/components/LPopup.vue\";\npolygonProps.latLngs.required = false;\nconst rectangleProps = {\n  ...polygonProps,\n  bounds: {\n    type: Array,\n    custom: true\n  }\n};\nconst setupRectangle = (props, leafletRef, context) => {\n  const {\n    options: polygonOptions,\n    methods: polygonMethods\n  } = setupPolygon(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, rectangleProps, polygonOptions);\n  const methods = {\n    ...polygonMethods,\n    setBounds(latLngBounds) {\n      leafletRef.value.setBounds(latLngBounds);\n    },\n    setLatLngs(latLngs) {\n      // Calling setLatLngs on a Leaflet rectangle will convert it\n      // to a polygon. So instead, we call setBounds here to ensure\n      // that the rectangle remains a rectangle, defined by the\n      // bounds of the points in the latLngs array.\n      leafletRef.value.setBounds(latLngs);\n    }\n  };\n  return {\n    options,\n    methods\n  };\n};\n\n/**\n * Rectangle component, lets you add and customize rectangular regions on the map\n */\nvar script$i = {\n  name: \"LRectangle\",\n  props: rectangleProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      options,\n      methods\n    } = setupRectangle(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        rectangle,\n        latLngBounds,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      const bounds = props.bounds && props.bounds.length ? latLngBounds(props.bounds) : latLngBounds(props.latLngs);\n      leafletRef.value = rectangle(bounds, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      ready,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  }\n};\nscript$i.__file = \"src/components/LRectangle.vue\";\nconst tileLayerProps = {\n  ...gridLayerProps,\n  tms: {\n    type: Boolean,\n    default: undefined\n  },\n  subdomains: {\n    type: String\n  },\n  detectRetina: {\n    type: Boolean,\n    default: undefined\n  },\n  url: {\n    type: String,\n    required: true,\n    custom: true\n  }\n};\nconst setupTileLayer = (props, leafletRef, context) => {\n  const {\n    options: gridLayerOptions,\n    methods: gridLayerMethods\n  } = setupGridLayer(props, leafletRef, context);\n  const options = propsToLeafletOptions(props, tileLayerProps, gridLayerOptions);\n  const methods = {\n    ...gridLayerMethods\n  };\n  return {\n    options,\n    methods\n  };\n};\nvar script$j = {\n  props: tileLayerProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      options,\n      methods\n    } = setupTileLayer(props, leafletRef, context);\n    onMounted(async () => {\n      const {\n        tileLayer,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = tileLayer(props.url, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return null;\n  }\n};\nscript$j.__file = \"src/components/LTileLayer.vue\";\nconst tooltipProps = {\n  ...popperProps\n};\nconst setupTooltip = (props, leafletRef) => {\n  const {\n    options,\n    methods\n  } = setupPopper(props, leafletRef);\n  const unbindTooltip = inject(\"unbindTooltip\");\n  onBeforeUnmount(() => {\n    unbindTooltip();\n  });\n  return {\n    options,\n    methods\n  };\n};\n\n/**\n * Display a tooltip on the map\n */\nvar script$k = {\n  name: \"LTooltip\",\n  props: tooltipProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindTooltip = inject(\"bindTooltip\");\n    const {\n      options,\n      methods\n    } = setupTooltip(props, leafletRef);\n    onMounted(async () => {\n      const {\n        tooltip,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = tooltip(options);\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindTooltip({\n        leafletObject: leafletRef.value\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      root,\n      leafletObject: leafletRef\n    };\n  },\n  render() {\n    return render$2(this.$slots);\n  }\n};\nscript$k.__file = \"src/components/LTooltip.vue\";\nconst wmsTileLayerProps = {\n  ...tileLayerProps,\n  layers: {\n    type: String,\n    required: true\n  },\n  styles: {\n    type: String\n  },\n  format: {\n    type: String\n  },\n  transparent: {\n    type: Boolean,\n    default: undefined\n  },\n  version: {\n    type: String\n  },\n  crs: {\n    type: Object\n  },\n  upperCase: {\n    type: Boolean,\n    default: undefined\n  }\n};\nconst setupWMSTileLayer = (props, leafletRef) => {\n  const {\n    options: tileLayerOptions,\n    methods: tileLayerMethods\n  } = setupTileLayer(props, leafletRef);\n  const options = propsToLeafletOptions(props, wmsTileLayerProps, tileLayerOptions);\n  return {\n    options,\n    methods: {\n      ...tileLayerMethods\n    }\n  };\n};\nvar script$l = {\n  props: wmsTileLayerProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n    const {\n      options,\n      methods\n    } = setupWMSTileLayer(props, leafletRef);\n    onMounted(async () => {\n      const {\n        tileLayer,\n        DomEvent\n      } = useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = tileLayer.wms(props.url, options);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return {\n      leafletObject: leafletRef.value\n    };\n  },\n  render() {\n    return null;\n  }\n};\nscript$l.__file = \"src/components/LWmsTileLayer.vue\";\nexport { script as LCircle, script$1 as LCircleMarker, script$2 as LControl, script$3 as LControlAttribution, script$4 as LControlLayers, script$5 as LControlScale, script$6 as LControlZoom, script$7 as LFeatureGroup, script$8 as LGeoJson, script$9 as LGridLayer, script$a as LIcon, script$b as LImageOverlay, script$c as LLayerGroup, script$d as LMap, script$e as LMarker, script$f as LPolygon, script$g as LPolyline, script$h as LPopup, script$i as LRectangle, script$j as LTileLayer, script$k as LTooltip, script$l as LWmsTileLayer };","map":{"version":3,"mappings":"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","names":["debounce","fn","time","timeout","args","context","clearTimeout","setTimeout","apply","capitalizeFirstLetter","string","charAt","toUpperCase","slice","isFunction","x","propsBinder","methods","leafletElement","props","key","setMethodName","watch","newVal","oldVal","propsToLeafletOptions","propValues","propDefinitions","baseOptions","output","prop","defn","val","custom","undefined","remapEvents","contextAttrs","result","attrName","startsWith","eventName","toLocaleLowerCase","resetWebpackIcon","Icon","modules","Promise","all","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","default","iconUrl","shadowUrl","provideLeafletWrapper","methodName","wrapped","ref","console","warn","wrapper","value","provide","updateLeafletWrapper","leafletMethod","WINDOW_OR_GLOBAL","self","global","GLOBAL_LEAFLET_OPT","componentProps","options","type","Object","setupComponent","layerProps","pane","String","attribution","name","layerType","visible","Boolean","setupLayer","leafletRef","addLayer","inject","removeLayer","componentOptions","componentMethods","addThisLayer","leafletObject","removeThisLayer","setAttribution","old","attributionControl","$parent","removeAttribution","addAttribution","setName","setLayerType","setVisible","isVisible","bindPopup","bindTooltip","unbindTooltip","tooltip","getTooltip","unbindPopup","popup","getPopup","updateVisibleProp","emit","onUnmounted","render","ready","slots","h","style","display","interactiveLayerProps","interactive","bubblingMouseEvents","setupInteractiveLayer","layerOptions","pathProps","stroke","color","weight","Number","opacity","lineCap","lineJoin","dashArray","dashOffset","fill","fillColor","fillOpacity","fillRule","className","setupPath","interactiveLayerOptions","interactiveLayerMethods","setStroke","setStyle","setColor","setWeight","setOpacity","setLineCap","setLineJoin","setDashArray","setDashOffset","setFill","setFillColor","setFillOpacity","setFillRule","setClassName","onBeforeUnmount","circleMarkerProps","radius","latLng","Array","required","setupCircleMarker","pathOptions","pathMethods","pathSetup","setRadius","setLatLng","circleProps","setupCircle","circleMarkerOptions","circleMarkerMethods","setup","useGlobalLeaflet","onMounted","circle","DomEvent","L","listeners","attrs","on","nextTick","$slots","circleMarker","controlProps","position","setupControl","setPosition","remove","disableClickPropagation","disableScrollPropagation","root","registerControl","Control","LControl","extend","onAdd","controlAttributionProps","prefix","setupControlAttribution","controlOptions","controlMethods","setPrefix","control","controlLayersProps","collapsed","autoZIndex","hideSingleBase","sortLayers","sortFunction","Function","setupControlLayers","layer","addBaseLayer","addOverlay","registerLayerControl","layers","controlScaleProps","maxWidth","metric","imperial","updateWhenIdle","setupControlScale","scale","controlZoomProps","zoomInText","zoomInTitle","zoomOutText","zoomOutTitle","setupControlZoom","zoom","layerGroupProps","setupLayerGroup","layerMethods","featureGroupProps","setupFeatureGroup","layerGroupMethods","featureGroup","geoJSONProps","geojson","setupGeoJSON","setGeojson","clearLayers","addData","getGeoJSONData","toGeoJSON","getBounds","geoJSON","gridLayerProps","zIndex","tileSize","noWrap","minZoom","maxZoom","setupGridLayer","childRender","tileComponents","GridLayer","DomUtil","onUnload","e","_tileCoordsToKey","coords","innerHTML","setTileComponent","redraw","GLayer","createTile","create","vNode","off","iconProps","iconSize","iconAnchor","popupAnchor","tooltipAnchor","shadowRetinaUrl","shadowSize","shadowAnchor","bgPos","canSetParentHtml","setParentHtml","setIcon","onDomEvent","offDomEvent","divIcon","icon","iconObject","createIcon","el","recreationNeeded","htmlSwapNeeded","elHtml","html","scheduleCreateIcon","scheduleHtmlSwap","setIconUrl","setIconRetinaUrl","setIconSize","setIconAnchor","setPopupAnchor","setTooltipAnchor","setShadowUrl","setShadowRetinaUrl","setShadowAnchor","setBgPos","setHtml","lDivIcon","lIcon","observer","MutationObserver","observe","attributes","childList","characterData","subtree","content","imageOverlayProps","alt","crossOrigin","errorOverlayUrl","url","bounds","setupImageOverlay","setUrl","setBounds","getElement","bringToFront","bringToBack","setZIndex","imageOverlay","layerGroup","mapProps","center","maxBounds","paddingBottomRight","paddingTopLeft","padding","worldCopyJump","crs","maxBoundsViscosity","inertia","inertiaDeceleration","inertiaMaxSpeed","easeLinearity","zoomAnimation","zoomAnimationThreshold","fadeAnimation","markerZoomAnimation","noBlockingAnimations","emits","blueprint","reactive","layersToAdd","layersInControl","eventHandlers","moveEndHandler","getZoom","getCenter","overlayAddHandler","find","l","overlayRemoveHandler","map","CRS","latLngBounds","beforeMapMount","error","message","optionsCrs","EPSG3857","layerControl","push","exist","_leaflet_id","filter","lControlLayer","forEach","lControl","addControl","setZoom","animate","setPaddingBottomRight","setPaddingTopLeft","setPadding","setCrs","prevBounds","fitBounds","newBounds","isValid","oldBounds","lastSetBounds","boundsChanged","equals","fitBoundsOptions","setCenter","newCenter","oldCenter","lastSetCenter","lat","lng","panTo","computed","width","height","markerProps","draggable","zIndexOffset","setupMarker","setDraggable","dragging","enable","disable","latLngSync","event","latlng","oldLatLng","getLatLng","newIcon","marker","polylineProps","smoothFactor","noClip","latLngs","setupPolyline","setSmoothFactor","setNoClip","addLatLng","polygonProps","setupPolygon","polylineOptions","polylineMethods","precision","polygon","polyline","popperProps","setupPopper","setContent","popupProps","setupPopup","rectangleProps","setupRectangle","polygonOptions","polygonMethods","setLatLngs","rectangle","length","tileLayerProps","tms","subdomains","detectRetina","setupTileLayer","gridLayerOptions","gridLayerMethods","tileLayer","tooltipProps","setupTooltip","wmsTileLayerProps","styles","format","transparent","version","upperCase","setupWMSTileLayer","tileLayerOptions","tileLayerMethods","wms"],"sources":["../src/utils.js","../src/functions/component.js","../src/functions/layer.js","../src/functions/interactiveLayer.js","../src/functions/path.js","../src/functions/circleMarker.js","../src/functions/circle.js","../src/components/LCircle.vue","../src/components/LCircleMarker.vue","../src/functions/control.js","../src/components/LControl.vue","../src/functions/controlAttribution.js","../src/components/LControlAttribution.vue","../src/functions/controlLayers.js","../src/components/LControlLayers.vue","../src/functions/controlScale.js","../src/components/LControlScale.vue","../src/functions/controlZoom.js","../src/components/LControlZoom.vue","../src/functions/layerGroup.js","../src/functions/featureGroup.js","../src/components/LFeatureGroup.vue","../src/functions/geoJSON.js","../src/components/LGeoJson.vue","../src/functions/gridLayer.js","../src/components/LGridLayer.vue","../src/functions/icon.js","../src/components/LIcon.vue","../src/functions/imageOverlay.js","../src/components/LImageOverlay.vue","../src/components/LLayerGroup.vue","../src/components/LMap.vue","../src/functions/marker.js","../src/components/LMarker.vue","../src/functions/polyline.js","../src/functions/polygon.js","../src/components/LPolygon.vue","../src/components/LPolyline.vue","../src/functions/popper.js","../src/functions/popup.js","../src/components/LPopup.vue","../src/functions/rectangle.js","../src/components/LRectangle.vue","../src/functions/tileLayer.js","../src/components/LTileLayer.vue","../src/functions/tooltip.js","../src/components/LTooltip.vue","../src/functions/wmsTileLayer.js","../src/components/LWmsTileLayer.vue"],"sourcesContent":["import { watch, ref, provide } from \"vue\";\n\nexport const debounce = (fn, time) => {\n  let timeout;\n\n  return function (...args) {\n    const context = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.apply(context, args);\n      timeout = null;\n    }, time);\n  };\n};\n\nexport const capitalizeFirstLetter = (string) => {\n  if (!string || typeof string.charAt !== \"function\") {\n    return string;\n  }\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nexport const isFunction = (x) => typeof x === \"function\";\n\nexport const propsBinder = (methods, leafletElement, props) => {\n  for (const key in props) {\n    const setMethodName = \"set\" + capitalizeFirstLetter(key);\n    if (methods[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal, oldVal) => {\n          methods[setMethodName](newVal, oldVal);\n        }\n      );\n    } else if (leafletElement[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal) => {\n          leafletElement[setMethodName](newVal);\n        }\n      );\n    }\n  }\n};\n\nexport const propsToLeafletOptions = (\n  propValues,\n  propDefinitions,\n  baseOptions = {}\n) => {\n  const output = { ...baseOptions };\n\n  for (const prop in propValues) {\n    const defn = propDefinitions[prop];\n    const val = propValues[prop];\n\n    // Unexpected props should not be converted to Leaflet options.\n    if (!defn) continue;\n    // Custom vue-leaflet props should not be passed to Leaflet.\n    if (defn && defn.custom === true) continue;\n    // Exclude undefined values so that Leaflet uses its own defaults.\n    if (val === undefined) continue;\n\n    output[prop] = val;\n  }\n\n  return output;\n};\n\nexport const remapEvents = (contextAttrs) => {\n  const result = {};\n  for (const attrName in contextAttrs) {\n    if (\n      attrName.startsWith(\"on\") &&\n      !attrName.startsWith(\"onUpdate\") &&\n      attrName !== \"onReady\"\n    ) {\n      const eventName = attrName.slice(2).toLocaleLowerCase();\n      result[eventName] = contextAttrs[attrName];\n    }\n  }\n  return result;\n};\n\nexport const resetWebpackIcon = async (Icon) => {\n  const modules = await Promise.all([\n    import(\"leaflet/dist/images/marker-icon-2x.png\"),\n    import(\"leaflet/dist/images/marker-icon.png\"),\n    import(\"leaflet/dist/images/marker-shadow.png\"),\n  ]);\n\n  delete Icon.Default.prototype._getIconUrl;\n\n  Icon.Default.mergeOptions({\n    iconRetinaUrl: modules[0].default,\n    iconUrl: modules[1].default,\n    shadowUrl: modules[2].default,\n  });\n};\n\n/**\n * Wraps a placeholder function and provides it with the given name.\n * The wrapper can later be updated with {@link updateLeafletWrapper}\n * to provide a different function.\n *\n * @param {String} methodName Key used to provide the wrapper function\n */\nexport const provideLeafletWrapper = (methodName) => {\n  const wrapped = ref(() =>\n    console.warn(`Method ${methodName} has been invoked without being replaced`)\n  );\n  const wrapper = (...args) => wrapped.value(...args);\n  // eslint-disable-next-line vue/no-ref-as-operand\n  wrapper.wrapped = wrapped;\n  provide(methodName, wrapper);\n\n  return wrapper;\n};\n\n/**\n * Change the function that will be executed when an injected Leaflet wrapper\n * is invoked.\n *\n * @param {*} wrapper Provided wrapper whose wrapped function is to be updated\n * @param {function} leafletMethod New method to be wrapped by the wrapper\n */\nexport const updateLeafletWrapper = (wrapper, leafletMethod) =>\n  (wrapper.wrapped.value = leafletMethod);\n\nexport const WINDOW_OR_GLOBAL =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  undefined;\n\nexport const GLOBAL_LEAFLET_OPT = \"useGlobalLeaflet\";\n","export const componentProps = {\n  options: {\n    type: Object,\n    default: () => ({}),\n    custom: true,\n  },\n};\n\nexport const setupComponent = (props) => {\n  return { options: props.options, methods: {} };\n};\n","import { onUnmounted, provide, inject, h } from \"vue\";\nimport { componentProps, setupComponent } from \"./component\";\nimport { isFunction, propsToLeafletOptions } from \"../utils\";\n\nexport const layerProps = {\n  ...componentProps,\n  pane: {\n    type: String,\n  },\n  attribution: {\n    type: String,\n  },\n  name: {\n    type: String,\n    custom: true,\n  },\n  layerType: {\n    type: String,\n    custom: true,\n  },\n  visible: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n};\n\nexport const setupLayer = (props, leafletRef, context) => {\n  const addLayer = inject(\"addLayer\");\n  const removeLayer = inject(\"removeLayer\");\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = setupComponent(props);\n\n  const options = propsToLeafletOptions(props, layerProps, componentOptions);\n\n  const addThisLayer = () => addLayer({ leafletObject: leafletRef.value });\n  const removeThisLayer = () =>\n    removeLayer({ leafletObject: leafletRef.value });\n\n  const methods = {\n    ...componentMethods,\n    setAttribution(val, old) {\n      const attributionControl = this.$parent.leafletObject.attributionControl;\n      attributionControl.removeAttribution(old).addAttribution(val);\n    },\n    setName() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setLayerType() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setVisible(isVisible) {\n      if (leafletRef.value) {\n        if (isVisible) {\n          addThisLayer();\n        } else {\n          removeThisLayer();\n        }\n      }\n    },\n    bindPopup({ leafletObject }) {\n      if (!leafletRef.value || !isFunction(leafletRef.value.bindPopup)) {\n        console.warn(\n          \"Attempt to bind popup before bindPopup method available on layer.\"\n        );\n\n        return;\n      }\n\n      leafletRef.value.bindPopup(leafletObject);\n    },\n    bindTooltip({ leafletObject }) {\n      if (!leafletRef.value || !isFunction(leafletRef.value.bindTooltip)) {\n        console.warn(\n          \"Attempt to bind tooltip before bindTooltip method available on layer.\"\n        );\n\n        return;\n      }\n\n      leafletRef.value.bindTooltip(leafletObject);\n    },\n    unbindTooltip() {\n      const tooltip =\n        leafletRef.value && isFunction(leafletRef.value.getTooltip)\n          ? leafletRef.value.getTooltip()\n          : null;\n      if (tooltip && isFunction(tooltip.unbindTooltip)) {\n        tooltip.unbindTooltip();\n      }\n    },\n    unbindPopup() {\n      const popup =\n        leafletRef.value && isFunction(leafletRef.value.getPopup)\n          ? leafletRef.value.getPopup()\n          : null;\n      if (popup && isFunction(popup.unbindPopup)) {\n        popup.unbindPopup();\n      }\n    },\n    updateVisibleProp(value) {\n      /**\n       * Triggers when the visible prop needs to be updated\n       * @type {boolean}\n       * @property {boolean} value - value of the visible property\n       */\n      context.emit(\"update:visible\", value);\n    },\n  };\n\n  provide(\"bindPopup\", methods.bindPopup);\n  provide(\"bindTooltip\", methods.bindTooltip);\n  provide(\"unbindTooltip\", methods.unbindTooltip);\n  provide(\"unbindPopup\", methods.unbindPopup);\n\n  onUnmounted(() => {\n    methods.unbindPopup();\n    methods.unbindTooltip();\n    removeThisLayer();\n  });\n\n  return { options, methods };\n};\n\nexport const render = (ready, slots) => {\n  if (ready && slots.default) {\n    return h(\"div\", { style: { display: \"none\" } }, slots.default());\n  }\n};\n","import { propsToLeafletOptions } from \"../utils\";\nimport { layerProps, setupLayer } from \"./layer\";\n\nexport const interactiveLayerProps = {\n  ...layerProps,\n  interactive: {\n    type: Boolean,\n    default: undefined,\n  },\n  bubblingMouseEvents: {\n    type: Boolean,\n    default: undefined,\n  },\n};\n\nexport const setupInteractiveLayer = (props, leafletRef, context) => {\n  const { options: layerOptions, methods } = setupLayer(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(\n    props,\n    interactiveLayerProps,\n    layerOptions\n  );\n\n  return { options, methods };\n};\n","import { onBeforeUnmount, inject } from \"vue\";\nimport {\n  interactiveLayerProps,\n  setupInteractiveLayer,\n} from \"./interactiveLayer\";\nimport { propsToLeafletOptions } from \"../utils\";\n\nexport const pathProps = {\n  ...interactiveLayerProps,\n  stroke: {\n    type: Boolean,\n    default: undefined,\n  },\n  color: {\n    type: String,\n  },\n  weight: {\n    type: Number,\n  },\n  opacity: {\n    type: Number,\n  },\n  lineCap: {\n    type: String,\n  },\n  lineJoin: {\n    type: String,\n  },\n  dashArray: {\n    type: String,\n  },\n  dashOffset: {\n    type: String,\n  },\n  fill: {\n    type: Boolean,\n    default: undefined,\n  },\n  fillColor: {\n    type: String,\n  },\n  fillOpacity: {\n    type: Number,\n  },\n  fillRule: {\n    type: String,\n  },\n  className: {\n    type: String,\n  },\n};\n\nexport const setupPath = (props, leafletRef, context) => {\n  const {\n    options: interactiveLayerOptions,\n    methods: interactiveLayerMethods,\n  } = setupInteractiveLayer(props, leafletRef, context);\n\n  const options = propsToLeafletOptions(\n    props,\n    pathProps,\n    interactiveLayerOptions\n  );\n\n  const removeLayer = inject(\"removeLayer\");\n  const methods = {\n    ...interactiveLayerMethods,\n    setStroke(stroke) {\n      leafletRef.value.setStyle({ stroke });\n    },\n    setColor(color) {\n      leafletRef.value.setStyle({ color });\n    },\n    setWeight(weight) {\n      leafletRef.value.setStyle({ weight });\n    },\n    setOpacity(opacity) {\n      leafletRef.value.setStyle({ opacity });\n    },\n    setLineCap(lineCap) {\n      leafletRef.value.setStyle({ lineCap });\n    },\n    setLineJoin(lineJoin) {\n      leafletRef.value.setStyle({ lineJoin });\n    },\n    setDashArray(dashArray) {\n      leafletRef.value.setStyle({ dashArray });\n    },\n    setDashOffset(dashOffset) {\n      leafletRef.value.setStyle({ dashOffset });\n    },\n    setFill(fill) {\n      leafletRef.value.setStyle({ fill });\n    },\n    setFillColor(fillColor) {\n      leafletRef.value.setStyle({ fillColor });\n    },\n    setFillOpacity(fillOpacity) {\n      leafletRef.value.setStyle({ fillOpacity });\n    },\n    setFillRule(fillRule) {\n      leafletRef.value.setStyle({ fillRule });\n    },\n    setClassName(className) {\n      leafletRef.value.setStyle({ className });\n    },\n  };\n\n  onBeforeUnmount(() => {\n    removeLayer({ leafletObject: leafletRef.value });\n  });\n\n  return { options, methods };\n};\n","import { propsToLeafletOptions } from \"../utils\";\nimport { pathProps as pathProps, setupPath as pathSetup } from \"./path\";\n\nexport const circleMarkerProps = {\n  ...pathProps,\n  /**\n   * Radius of the marker in pixels.\n   */\n  radius: {\n    type: Number,\n  },\n  latLng: {\n    type: [Object, Array],\n    required: true,\n    custom: true,\n  },\n};\n\nexport const setupCircleMarker = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = pathSetup(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(props, circleMarkerProps, pathOptions);\n\n  const methods = {\n    ...pathMethods,\n    setRadius(radius) {\n      leafletRef.value.setRadius(radius);\n    },\n    setLatLng(latLng) {\n      leafletRef.value.setLatLng(latLng);\n    },\n  };\n\n  return { options, methods };\n};\n","import { propsToLeafletOptions } from \"../utils\";\nimport { circleMarkerProps, setupCircleMarker } from \"./circleMarker\";\n\nexport const circleProps = {\n  ...circleMarkerProps,\n  /**\n   * Radius of the circle in meters.\n   */\n  radius: {\n    type: Number,\n  },\n};\n\nexport const setupCircle = (props, leafletRef, context) => {\n  const {\n    options: circleMarkerOptions,\n    methods: circleMarkerMethods,\n  } = setupCircleMarker(props, leafletRef, context);\n\n  const options = propsToLeafletOptions(\n    props,\n    circleProps,\n    circleMarkerOptions\n  );\n\n  const methods = {\n    ...circleMarkerMethods,\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { circleProps, setupCircle } from \"../functions/circle\";\nimport { render } from \"../functions/layer\";\n\n/**\n * Circle component, lets you add and personalize circles on the map\n */\nexport default {\n  name: \"LCircle\",\n  props: circleProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setupCircle(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { circle, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = circle(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport {\n  circleMarkerProps,\n  setupCircleMarker,\n} from \"../functions/circleMarker\";\nimport { render } from \"../functions/layer\";\n\n/**\n * Circle Marker component, lets you add and personalize circle markers on the map\n */\nexport default {\n  name: \"LCircleMarker\",\n  props: circleMarkerProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setupCircleMarker(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { circleMarker, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = circleMarker(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","import { onUnmounted, h } from \"vue\";\nimport { propsToLeafletOptions } from \"../utils\";\nimport { componentProps, setupComponent } from \"./component\";\n\nexport const controlProps = {\n  ...componentProps,\n  position: {\n    type: String,\n  },\n};\n\nexport const setupControl = (props, leafletRef) => {\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = setupComponent(props);\n\n  const options = propsToLeafletOptions(props, controlProps, componentOptions);\n\n  const methods = {\n    ...componentMethods,\n    setPosition(position) {\n      if (leafletRef.value) {\n        leafletRef.value.setPosition(position);\n      }\n    },\n  };\n\n  onUnmounted(() => {\n    if (leafletRef.value) {\n      leafletRef.value.remove();\n    }\n  });\n\n  return { options, methods };\n};\n\nexport const render = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n\n  return null;\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport { controlProps, setupControl, render } from \"../functions/control\";\nimport { propsBinder, WINDOW_OR_GLOBAL, GLOBAL_LEAFLET_OPT } from \"../utils.js\";\n\nexport default {\n  name: \"LControl\",\n  props: {\n    ...controlProps,\n    disableClickPropagation: {\n      type: Boolean,\n      custom: true,\n      default: true,\n    },\n    disableScrollPropagation: {\n      type: Boolean,\n      custom: true,\n      default: false,\n    },\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setupControl(props, leafletRef);\n\n    onMounted(async () => {\n      const { Control, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      const LControl = Control.extend({\n        onAdd() {\n          return root.value;\n        },\n      });\n\n      leafletRef.value = new LControl(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n\n      if (props.disableClickPropagation) {\n        DomEvent.disableClickPropagation(root.value);\n      }\n      if (props.disableScrollPropagation) {\n        DomEvent.disableScrollPropagation(root.value);\n      }\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.$slots);\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { controlProps, setupControl } from \"./control\";\n\nexport const controlAttributionProps = {\n  ...controlProps,\n  prefix: {\n    type: String,\n  },\n};\n\nexport const setupControlAttribution = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setupControl(\n    props,\n    leafletRef\n  );\n\n  const options = propsToLeafletOptions(\n    props,\n    controlAttributionProps,\n    controlOptions\n  );\n\n  const methods = {\n    ...controlMethods,\n    setPrefix(prefix) {\n      leafletRef.value.setPrefix(prefix);\n    },\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  controlAttributionProps,\n  setupControlAttribution,\n} from \"../functions/controlAttribution\";\nimport { propsBinder, WINDOW_OR_GLOBAL, GLOBAL_LEAFLET_OPT } from \"../utils.js\";\n\nexport default {\n  name: \"LControlAttribution\",\n  props: controlAttributionProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setupControlAttribution(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = control.attribution(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { controlProps, setupControl } from \"./control\";\n\nexport const controlLayersProps = {\n  ...controlProps,\n  collapsed: {\n    type: Boolean,\n    default: undefined,\n  },\n  autoZIndex: {\n    type: Boolean,\n    default: undefined,\n  },\n  hideSingleBase: {\n    type: Boolean,\n    default: undefined,\n  },\n  sortLayers: {\n    type: Boolean,\n    default: undefined,\n  },\n  sortFunction: {\n    type: Function,\n  },\n};\n\nexport const setupControlLayers = (props, leafletRef) => {\n  const { options: controlOptions } = setupControl(props, leafletRef);\n\n  const options = propsToLeafletOptions(\n    props,\n    controlLayersProps,\n    controlOptions\n  );\n\n  const methods = {\n    addLayer(layer) {\n      if (layer.layerType === \"base\") {\n        leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);\n      } else if (layer.layerType === \"overlay\") {\n        leafletRef.value.addOverlay(layer.leafletObject, layer.name);\n      }\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  controlLayersProps,\n  setupControlLayers,\n} from \"../functions/controlLayers\";\nimport { propsBinder, WINDOW_OR_GLOBAL, GLOBAL_LEAFLET_OPT } from \"../utils.js\";\n\nexport default {\n  name: \"LControlLayers\",\n  props: controlLayersProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerLayerControl = inject(\"registerLayerControl\");\n\n    const { options, methods } = setupControlLayers(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = control.layers(null, null, options);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      registerLayerControl({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { controlProps, setupControl } from \"./control\";\n\nexport const controlScaleProps = {\n  ...controlProps,\n  maxWidth: {\n    type: Number,\n  },\n  metric: {\n    type: Boolean,\n    default: undefined,\n  },\n  imperial: {\n    type: Boolean,\n    default: undefined,\n  },\n  updateWhenIdle: {\n    type: Boolean,\n    default: undefined,\n  },\n};\n\nexport const setupControlScale = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setupControl(\n    props,\n    leafletRef\n  );\n\n  const options = propsToLeafletOptions(\n    props,\n    controlScaleProps,\n    controlOptions\n  );\n\n  return { options, methods: controlMethods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  controlScaleProps,\n  setupControlScale,\n} from \"../functions/controlScale\";\nimport { propsBinder, WINDOW_OR_GLOBAL, GLOBAL_LEAFLET_OPT } from \"../utils.js\";\n\nexport default {\n  name: \"LControlScale\",\n  props: controlScaleProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setupControlScale(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = control.scale(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { controlProps, setupControl } from \"./control\";\n\nexport const controlZoomProps = {\n  ...controlProps,\n  zoomInText: {\n    type: String,\n  },\n  zoomInTitle: {\n    type: String,\n  },\n  zoomOutText: {\n    type: String,\n  },\n  zoomOutTitle: {\n    type: String,\n  },\n};\n\nexport const setupControlZoom = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setupControl(\n    props,\n    leafletRef\n  );\n\n  const options = propsToLeafletOptions(\n    props,\n    controlZoomProps,\n    controlOptions\n  );\n\n  return { options, methods: controlMethods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport { controlZoomProps, setupControlZoom } from \"../functions/controlZoom\";\nimport { propsBinder, WINDOW_OR_GLOBAL, GLOBAL_LEAFLET_OPT } from \"../utils.js\";\n\nexport default {\n  name: \"LControlZoom\",\n  props: controlZoomProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setupControlZoom(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = control.zoom(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n</script>\n","import { provide } from \"vue\";\nimport { propsToLeafletOptions } from \"../utils\";\nimport { layerProps, setupLayer } from \"./layer\";\n\nexport const layerGroupProps = {\n  ...layerProps,\n};\n\nexport const setupLayerGroup = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setupLayer(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(props, layerGroupProps, layerOptions);\n\n  const methods = {\n    ...layerMethods,\n    addLayer(layer) {\n      leafletRef.value.addLayer(layer.leafletObject);\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n\n  provide(\"addLayer\", methods.addLayer);\n  provide(\"removeLayer\", methods.removeLayer);\n\n  return { options, methods };\n};\n","import { propsToLeafletOptions } from \"../utils\";\nimport { layerGroupProps, setupLayerGroup } from \"./layerGroup\";\n\nexport const featureGroupProps = {\n  ...layerGroupProps,\n};\n\nexport const setupFeatureGroup = (props, leafletRef) => {\n  const { options: layerOptions, methods: layerGroupMethods } = setupLayerGroup(\n    props,\n    leafletRef\n  );\n\n  const options = propsToLeafletOptions(props, featureGroupProps, layerOptions);\n\n  const methods = {\n    ...layerGroupMethods,\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport {\n  featureGroupProps,\n  setupFeatureGroup,\n} from \"../functions/featureGroup\";\nimport { render } from \"../functions/layer\";\n\nexport default {\n  props: featureGroupProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods, options } = setupFeatureGroup(props, leafletRef);\n\n    onMounted(async () => {\n      const { featureGroup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = featureGroup(options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { layerGroupProps, setupLayerGroup } from \"./layerGroup\";\n\nexport const geoJSONProps = {\n  ...layerGroupProps,\n  geojson: {\n    type: [Object, Array],\n    custom: true,\n  },\n};\n\nexport const setupGeoJSON = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerGroupMethods } = setupLayerGroup(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(props, geoJSONProps, layerOptions);\n\n  const methods = {\n    ...layerGroupMethods,\n    setGeojson(newVal) {\n      leafletRef.value.clearLayers();\n      leafletRef.value.addData(newVal);\n    },\n    getGeoJSONData() {\n      return leafletRef.value.toGeoJSON();\n    },\n    getBounds() {\n      return leafletRef.value.getBounds();\n    },\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { geoJSONProps, setupGeoJSON } from \"../functions/geoJSON\";\nimport { render } from \"../functions/layer\";\n\nexport default {\n  props: geoJSONProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods, options } = setupGeoJSON(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { geoJSON, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = geoJSON(props.geojson, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { layerProps, setupLayer } from \"./layer\";\n\nexport const gridLayerProps = {\n  ...layerProps,\n  opacity: {\n    type: Number,\n  },\n  zIndex: {\n    type: Number,\n  },\n  tileSize: {\n    type: Number,\n  },\n  noWrap: {\n    type: Boolean,\n    default: undefined,\n  },\n  minZoom: {\n    type: Number,\n  },\n  maxZoom: {\n    type: Number,\n  },\n};\n\nexport const setupGridLayer = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setupLayer(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(props, gridLayerProps, layerOptions);\n\n  return { options, methods: { ...layerMethods } };\n};\n","<script>\nimport { onMounted, onUnmounted, ref, inject, nextTick, h, render } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { gridLayerProps, setupGridLayer } from \"../functions/gridLayer\";\n\nexport default {\n  props: {\n    ...gridLayerProps,\n    childRender: {\n      type: Function,\n      required: true,\n    },\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const tileComponents = ref({});\n    const root = ref(null);\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setupGridLayer(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { GridLayer, DomEvent, DomUtil } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      methods.onUnload = (e) => {\n        const key = leafletRef.value._tileCoordsToKey(e.coords);\n        if (tileComponents[key]) {\n          tileComponents[key].innerHTML = \"\";\n          tileComponents[key] = undefined;\n        }\n      };\n\n      methods.setTileComponent = () => {\n        leafletRef.value.redraw();\n      };\n\n      const GLayer = GridLayer.extend({\n        createTile(coords) {\n          const key = leafletRef.value._tileCoordsToKey(coords);\n          tileComponents[key] = DomUtil.create(\"div\");\n\n          let vNode = h(\n            { setup: props.childRender, props: [\"coords\"] },\n            { coords }\n          );\n          render(vNode, tileComponents[key]);\n\n          return tileComponents[key];\n        },\n      });\n\n      leafletRef.value = new GLayer(options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      leafletRef.value.on(\"tileunload\", methods.onUnload);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    onUnmounted(() => {\n      leafletRef.value.off(\"tileunload\", methods.onUnload);\n    });\n\n    return { root, ready, leafletObject: leafletRef };\n  },\n  render() {\n    if (this.ready) {\n      return h(\"div\", { style: { display: \"none\" }, ref: \"root\" });\n    }\n    return null;\n  },\n};\n</script>\n","export const iconProps = {\n  iconUrl: {\n    type: String,\n  },\n  iconRetinaUrl: {\n    type: String,\n  },\n  iconSize: {\n    type: [Object, Array],\n  },\n  iconAnchor: {\n    type: [Object, Array],\n  },\n  popupAnchor: {\n    type: [Object, Array],\n  },\n  tooltipAnchor: {\n    type: [Object, Array],\n  },\n  shadowUrl: {\n    type: String,\n  },\n  shadowRetinaUrl: {\n    type: String,\n  },\n  shadowSize: {\n    type: [Object, Array],\n  },\n  shadowAnchor: {\n    type: [Object, Array],\n  },\n  bgPos: {\n    type: [Object, Array],\n  },\n  className: {\n    type: String,\n  },\n};\n","<script>\nimport { onMounted, ref, inject, nextTick, h } from \"vue\";\nimport {\n  propsBinder,\n  remapEvents,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n  propsToLeafletOptions,\n} from \"../utils\";\nimport { iconProps } from \"../functions/icon\";\nimport { componentProps, setupComponent } from \"../functions/component\";\n\n/**\n * Icon component, lets you add and custom icons to the map\n */\nexport default {\n  name: \"LIcon\",\n  props: {\n    ...iconProps,\n    ...componentProps,\n  },\n  setup(props, context) {\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const canSetParentHtml = inject(\"canSetParentHtml\");\n    const setParentHtml = inject(\"setParentHtml\");\n    const setIcon = inject(\"setIcon\");\n\n    let onDomEvent;\n    let offDomEvent;\n    let divIcon;\n    let icon;\n    let iconObject = undefined;\n\n    const createIcon = (el, recreationNeeded, htmlSwapNeeded) => {\n      const elHtml = el && el.innerHTML;\n      if (!recreationNeeded) {\n        if (htmlSwapNeeded && iconObject && canSetParentHtml()) {\n          setParentHtml(elHtml);\n        }\n        return;\n      }\n\n      const listeners = remapEvents(context.attrs);\n      if (iconObject) {\n        offDomEvent(iconObject, listeners);\n      }\n\n      const { options: componentOptions } = setupComponent(props);\n      const options = propsToLeafletOptions(props, iconProps, componentOptions);\n      if (elHtml) {\n        options.html = elHtml;\n      }\n\n      iconObject = options.html ? divIcon(options) : icon(options);\n      onDomEvent(iconObject, listeners);\n      setIcon(iconObject);\n    };\n\n    const scheduleCreateIcon = () => {\n      nextTick(() => createIcon(root.value, true, false));\n    };\n\n    const scheduleHtmlSwap = () => {\n      nextTick(() => createIcon(root.value, false, true));\n    };\n\n    const methods = {\n      setIconUrl: scheduleCreateIcon,\n      setIconRetinaUrl: scheduleCreateIcon,\n      setIconSize: scheduleCreateIcon,\n      setIconAnchor: scheduleCreateIcon,\n      setPopupAnchor: scheduleCreateIcon,\n      setTooltipAnchor: scheduleCreateIcon,\n      setShadowUrl: scheduleCreateIcon,\n      setShadowRetinaUrl: scheduleCreateIcon,\n      setShadowAnchor: scheduleCreateIcon,\n      setBgPos: scheduleCreateIcon,\n      setClassName: scheduleCreateIcon,\n      setHtml: scheduleCreateIcon,\n    };\n\n    onMounted(async () => {\n      const { DomEvent, divIcon: lDivIcon, icon: lIcon } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      onDomEvent = DomEvent.on;\n      offDomEvent = DomEvent.off;\n      divIcon = lDivIcon;\n      icon = lIcon;\n\n      propsBinder(methods, {}, props);\n\n      const observer = new MutationObserver(scheduleHtmlSwap);\n      observer.observe(root.value, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true,\n      });\n      scheduleCreateIcon();\n    });\n\n    return { root };\n  },\n  render() {\n    const content = this.$slots.default ? this.$slots.default() : undefined;\n    return h(\"div\", { ref: \"root\" }, content);\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { layerProps, setupLayer } from \"./layer\";\n/**\n * @typedef {import('leaflet/dist/leaflet-src.esm.js').LatLngBounds} LatLngBounds\n */\n\nexport const imageOverlayProps = {\n  ...layerProps,\n  opacity: {\n    type: Number,\n  },\n  alt: {\n    type: String,\n  },\n  interactive: {\n    type: Boolean,\n    default: undefined,\n  },\n  crossOrigin: {\n    type: Boolean,\n    default: undefined,\n  },\n  errorOverlayUrl: {\n    type: String,\n  },\n  zIndex: {\n    type: Number,\n  },\n  className: {\n    type: String,\n  },\n  url: {\n    type: String,\n    required: true,\n    custom: true,\n  },\n  bounds: {\n    type: [Array, Object],\n    required: true,\n    custom: true,\n  },\n};\n\nexport const setupImageOverlay = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setupLayer(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(props, imageOverlayProps, layerOptions);\n\n  const methods = {\n    ...layerMethods,\n    /**\n     * Sets the opacity of the overlay.\n     * @param {number} opacity\n     */\n    setOpacity(opacity) {\n      return leafletRef.value.setOpacity(opacity);\n    },\n    /**\n     * Changes the URL of the image.\n     * @param {string} url\n     */\n    setUrl(url) {\n      return leafletRef.value.setUrl(url);\n    },\n    /**\n     * Update the bounds that this ImageOverlay covers\n     * @param {LatLngBounds | Array<Array<number>>} bounds\n     */\n    setBounds(bounds) {\n      return leafletRef.value.setBounds(bounds);\n    },\n    /**\n     * Get the bounds that this ImageOverlay covers\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n      return leafletRef.value.getBounds();\n    },\n    /**\n     * Returns the instance of HTMLImageElement used by this overlay.\n     * @returns {HTMLElement}\n     */\n    getElement() {\n      return leafletRef.value.getElement();\n    },\n    /**\n     * Brings the layer to the top of all overlays.\n     */\n    bringToFront() {\n      return leafletRef.value.bringToFront();\n    },\n    /**\n     * Brings the layer to the bottom of all overlays.\n     */\n    bringToBack() {\n      return leafletRef.value.bringToBack();\n    },\n    /**\n     * Changes the zIndex of the image overlay.\n     * @param {number} zIndex\n     */\n    setZIndex(zIndex) {\n      return leafletRef.value.setZIndex(zIndex);\n    },\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport {\n  imageOverlayProps,\n  setupImageOverlay,\n} from \"../functions/imageOverlay\";\nimport { render } from \"../functions/layer\";\n\n/**\n * ImageOverlay component, render a plain image instead of a geospatial map.\n */\nexport default {\n  name: \"LImageOverlay\",\n  props: imageOverlayProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setupImageOverlay(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { imageOverlay, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n      leafletRef.value = imageOverlay(props.url, props.bounds, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { layerGroupProps, setupLayerGroup } from \"../functions/layerGroup\";\nimport { render } from \"../functions/layer\";\n\nexport default {\n  props: layerGroupProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods } = setupLayerGroup(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { layerGroup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n      leafletRef.value = layerGroup(props.options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","<script>\nimport {\n  computed,\n  h,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n} from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  debounce,\n  resetWebpackIcon,\n  provideLeafletWrapper,\n  updateLeafletWrapper,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n  propsToLeafletOptions,\n} from \"../utils.js\";\nimport { componentProps, setupComponent } from \"../functions/component\";\n\nconst mapProps = {\n  ...componentProps,\n  /**\n   * The center of the map, supports .sync modifier\n   */\n  center: {\n    type: [Object, Array],\n  },\n  /**\n   * The bounds of the map, supports .sync modifier\n   */\n  bounds: {\n    type: [Array, Object],\n  },\n  /**\n   * The max bounds of the map\n   */\n  maxBounds: {\n    type: [Array, Object],\n  },\n  /**\n   * The zoom of the map, supports .sync modifier\n   */\n  zoom: {\n    type: Number,\n  },\n  /**\n   * The minZoom of the map\n   */\n  minZoom: {\n    type: Number,\n  },\n  /**\n   * The maxZoom of the map\n   */\n  maxZoom: {\n    type: Number,\n  },\n  /**\n   * The paddingBottomRight of the map\n   */\n  paddingBottomRight: {\n    type: Array,\n  },\n  /**\n   * The paddingTopLeft of the map\n   */\n  paddingTopLeft: {\n    type: Array,\n  },\n  /**\n   * The padding of the map\n   */\n  padding: {\n    type: Array,\n  },\n  /**\n   * The worldCopyJump option for the map\n   */\n  worldCopyJump: {\n    type: Boolean,\n    default: undefined,\n  },\n  /**\n   * The CRS to use for the map. Can be an object that defines a coordinate reference\n   * system for projecting geographical points into screen coordinates and back\n   * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string\n   * name identifying one of Leaflet's defined CRSs, such as \"EPSG4326\".\n   */\n  crs: {\n    type: [String, Object],\n  },\n  maxBoundsViscosity: {\n    type: Number,\n  },\n  inertia: {\n    type: Boolean,\n    default: undefined,\n  },\n  inertiaDeceleration: {\n    type: Number,\n  },\n  inertiaMaxSpeed: {\n    type: Number,\n  },\n  easeLinearity: {\n    type: Number,\n  },\n  zoomAnimation: {\n    type: Boolean,\n    default: undefined,\n  },\n  zoomAnimationThreshold: {\n    type: Number,\n  },\n  fadeAnimation: {\n    type: Boolean,\n    default: undefined,\n  },\n  markerZoomAnimation: {\n    type: Boolean,\n    default: undefined,\n  },\n  noBlockingAnimations: {\n    type: Boolean,\n    default: undefined,\n  },\n  useGlobalLeaflet: {\n    type: Boolean,\n    default: undefined,\n  },\n};\n\nexport default {\n  emits: [\"ready\", \"update:zoom\", \"update:center\", \"update:bounds\"],\n  props: mapProps,\n  setup(props, context) {\n    const root = ref(null);\n    const blueprint = reactive({\n      ready: false,\n      leafletRef: {},\n      layersToAdd: [],\n      layersInControl: [],\n    });\n\n    const { options: componentOptions } = setupComponent(props);\n\n    const options = propsToLeafletOptions(props, mapProps, componentOptions);\n\n    const addLayer = provideLeafletWrapper(\"addLayer\");\n    const removeLayer = provideLeafletWrapper(\"removeLayer\");\n    const registerControl = provideLeafletWrapper(\"registerControl\");\n    const registerLayerControl = provideLeafletWrapper(\"registerLayerControl\");\n    provide(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);\n\n    const eventHandlers = {\n      moveEndHandler() {\n        /**\n         * Triggers when zoom is updated\n         * @type {number,string}\n         */\n        context.emit(\"update:zoom\", blueprint.leafletRef.getZoom());\n        /**\n         * Triggers when center is updated\n         * @type {object,array}\n         */\n        context.emit(\"update:center\", blueprint.leafletRef.getCenter());\n\n        /**\n         * Triggers when bounds are updated\n         * @type {object}\n         */\n        context.emit(\"update:bounds\", blueprint.leafletRef.getBounds());\n      },\n      overlayAddHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(true);\n        }\n      },\n      overlayRemoveHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(false);\n        }\n      },\n    };\n\n    onMounted(async () => {\n      if (props.useGlobalLeaflet) {\n        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await import(\"leaflet\"));\n      }\n      const {\n        map,\n        CRS,\n        Icon,\n        latLngBounds,\n        latLng,\n        DomEvent,\n      } = props.useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      try {\n        options.beforeMapMount && (await options.beforeMapMount());\n      } catch (error) {\n        console.error(\n          `The following error occurred running the provided beforeMapMount hook ${error.message}`\n        );\n      }\n\n      await resetWebpackIcon(Icon);\n\n      const optionsCrs =\n        typeof options.crs == \"string\" ? CRS[options.crs] : options.crs;\n      options.crs = optionsCrs || CRS.EPSG3857;\n\n      const methods = {\n        addLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd.push(layer);\n            } else {\n              const exist = blueprint.layersInControl.find(\n                (l) =>\n                  l.leafletObject._leaflet_id ===\n                  layer.leafletObject._leaflet_id\n              );\n              if (!exist) {\n                blueprint.layerControl.addLayer(layer);\n                blueprint.layersInControl.push(layer);\n              }\n            }\n          }\n          if (layer.visible !== false) {\n            blueprint.leafletRef.addLayer(layer.leafletObject);\n          }\n        },\n        removeLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd = blueprint.layersToAdd.filter(\n                (l) => l.name !== layer.name\n              );\n            } else {\n              blueprint.layerControl.removeLayer(layer.leafletObject);\n              blueprint.layersInControl = blueprint.layersInControl.filter(\n                (l) =>\n                  l.leafletObject._leaflet_id !==\n                  layer.leafletObject._leaflet_id\n              );\n            }\n          }\n          blueprint.leafletRef.removeLayer(layer.leafletObject);\n        },\n\n        registerLayerControl(lControlLayer) {\n          blueprint.layerControl = lControlLayer;\n          blueprint.layersToAdd.forEach((layer) => {\n            blueprint.layerControl.addLayer(layer);\n          });\n          blueprint.layersToAdd = [];\n\n          registerControl(lControlLayer);\n        },\n\n        registerControl(lControl) {\n          blueprint.leafletRef.addControl(lControl.leafletObject);\n        },\n\n        setZoom(newVal) {\n          const zoom = blueprint.leafletRef.getZoom();\n          if (newVal !== zoom) {\n            blueprint.leafletRef.setZoom(newVal, {\n              animate: props.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n\n        setPaddingBottomRight(newVal) {\n          blueprint.paddingBottomRight = newVal;\n        },\n        setPaddingTopLeft(newVal) {\n          blueprint.paddingTopLeft = newVal;\n        },\n        setPadding(newVal) {\n          blueprint.padding = newVal;\n        },\n        setCrs(newVal) {\n          const prevBounds = blueprint.leafletRef.getBounds();\n          blueprint.leafletRef.options.crs = newVal;\n          blueprint.leafletRef.fitBounds(prevBounds, {\n            animate: false,\n            padding: [0, 0],\n          });\n        },\n        fitBounds(bounds) {\n          blueprint.leafletRef.fitBounds(bounds, {\n            animate: this.noBlockingAnimations ? false : null,\n          });\n        },\n        setBounds(newVal) {\n          if (!newVal) {\n            return;\n          }\n          const newBounds = latLngBounds(newVal);\n          if (!newBounds.isValid()) {\n            return;\n          }\n          const oldBounds =\n            blueprint.lastSetBounds || blueprint.leafletRef.getBounds();\n          const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals\n          if (boundsChanged) {\n            blueprint.lastSetBounds = newBounds;\n            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);\n          }\n        },\n\n        setCenter(newVal) {\n          if (newVal == null) {\n            return;\n          }\n          const newCenter = latLng(newVal);\n          const oldCenter =\n            blueprint.lastSetCenter || blueprint.leafletRef.getCenter();\n          if (\n            oldCenter.lat !== newCenter.lat ||\n            oldCenter.lng !== newCenter.lng\n          ) {\n            blueprint.lastSetCenter = newCenter;\n            blueprint.leafletRef.panTo(newCenter, {\n              animate: this.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n      };\n\n      updateLeafletWrapper(addLayer, methods.addLayer);\n      updateLeafletWrapper(removeLayer, methods.removeLayer);\n      updateLeafletWrapper(registerControl, methods.registerControl);\n      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);\n\n      blueprint.leafletRef = map(root.value, options);\n\n      propsBinder(methods, blueprint.leafletRef, props);\n      const listeners = remapEvents(context.attrs);\n\n      blueprint.leafletRef.on(\n        \"moveend\",\n        debounce(eventHandlers.moveEndHandler, 100)\n      );\n      blueprint.leafletRef.on(\"overlayadd\", eventHandlers.overlayAddHandler);\n      blueprint.leafletRef.on(\n        \"overlayremove\",\n        eventHandlers.overlayRemoveHandler\n      );\n      DomEvent.on(blueprint.leafletRef, listeners);\n      blueprint.ready = true;\n      nextTick(() => context.emit(\"ready\", blueprint.leafletRef));\n    });\n\n    onBeforeUnmount(() => {\n      if (blueprint.leafletRef) {\n        blueprint.leafletRef.off();\n        blueprint.leafletRef.remove();\n      }\n    });\n\n    const leafletObject = computed(() => blueprint.leafletRef);\n    const ready = computed(() => blueprint.ready);\n    return { root, ready, leafletObject };\n  },\n  render() {\n    return h(\n      \"div\",\n      { style: { width: \"100%\", height: \"100%\" }, ref: \"root\" },\n      this.ready ? this.$slots.default() : {}\n    );\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { layerProps, setupLayer } from \"./layer\";\n\nexport const markerProps = {\n  ...layerProps,\n  draggable: {\n    type: Boolean,\n    default: undefined,\n  },\n  icon: {\n    type: [Object],\n  },\n  zIndexOffset: {\n    type: Number,\n  },\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    required: true,\n  },\n};\n\nexport const setupMarker = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setupLayer(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(props, markerProps, layerOptions);\n\n  const methods = {\n    ...layerMethods,\n    setDraggable(value) {\n      if (leafletRef.value.dragging) {\n        value\n          ? leafletRef.value.dragging.enable()\n          : leafletRef.value.dragging.disable();\n      }\n    },\n    latLngSync(event) {\n      context.emit(\"update:latLng\", event.latlng);\n      context.emit(\"update:lat-lng\", event.latlng);\n    },\n    setLatLng(newVal) {\n      if (newVal == null) {\n        return;\n      }\n\n      if (leafletRef.value) {\n        const oldLatLng = leafletRef.value.getLatLng();\n        if (!oldLatLng || !oldLatLng.equals(newVal)) {\n          leafletRef.value.setLatLng(newVal);\n        }\n      }\n    },\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, provide, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  debounce,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { markerProps, setupMarker } from \"../functions/marker\";\nimport { render } from \"../functions/layer\";\n\n/**\n * Marker component, lets you add and personalize markers on the map\n */\nexport default {\n  name: \"LMarker\",\n  props: markerProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    provide(\"canSetParentHtml\", () => !!leafletRef.value.getElement());\n    provide(\n      \"setParentHtml\",\n      (html) => (leafletRef.value.getElement().innerHTML = html)\n    );\n    provide(\n      \"setIcon\",\n      (newIcon) => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon)\n    );\n    const { options, methods } = setupMarker(props, leafletRef, context);\n    if (options.icon === undefined) {\n      // If the options object has a property named 'icon', then Leaflet will overwrite\n      // the default icon with it for the marker, _even if it is undefined_.\n      // This leads to the issue discussed in https://github.com/vue-leaflet/vue-leaflet/issues/130\n      delete options.icon;\n    }\n\n    onMounted(async () => {\n      const { marker, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n      leafletRef.value = marker(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      leafletRef.value.on(\"move\", debounce(methods.latLngSync, 100));\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { pathProps, setupPath } from \"./path\";\n\nexport const polylineProps = {\n  ...pathProps,\n  smoothFactor: {\n    type: Number,\n  },\n  noClip: {\n    type: Boolean,\n    default: undefined,\n  },\n  latLngs: {\n    type: Array,\n    required: true,\n    custom: true,\n  },\n};\n\nexport const setupPolyline = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = setupPath(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(props, polylineProps, pathOptions);\n\n  const methods = {\n    ...pathMethods,\n    setSmoothFactor(smoothFactor) {\n      leafletRef.value.setStyle({ smoothFactor });\n    },\n    setNoClip(noClip) {\n      leafletRef.value.setStyle({ noClip });\n    },\n    addLatLng(latLng) {\n      leafletRef.value.addLatLng(latLng);\n    },\n  };\n\n  return { options, methods };\n};\n","import { propsToLeafletOptions } from \"../utils\";\nimport { polylineProps, setupPolyline } from \"./polyline\";\n\nexport const polygonProps = {\n  ...polylineProps,\n};\n\nexport const setupPolygon = (props, leafletRef, context) => {\n  const { options: polylineOptions, methods: polylineMethods } = setupPolyline(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(props, polygonProps, polylineOptions);\n\n  const methods = {\n    ...polylineMethods,\n    toGeoJSON(precision) {\n      return leafletRef.value.toGeoJSON(precision);\n    },\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { polygonProps, setupPolygon } from \"../functions/polygon\";\nimport { render } from \"../functions/layer\";\n\n/**\n * Polygon component, lets you add and customize polygon regions on the map\n */\nexport default {\n  name: \"LPolygon\",\n  props: polygonProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setupPolygon(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { polygon, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = polygon(props.latLngs, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { polylineProps, setupPolyline } from \"../functions/polyline\";\nimport { render } from \"../functions/layer\";\n\n/**\n * Polyline component, lets you add and personalize polylines on the map\n */\nexport default {\n  name: \"LPolyline\",\n  props: polylineProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setupPolyline(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { polyline, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = polyline(props.latLngs, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","import { h } from \"vue\";\nimport { componentProps, setupComponent } from \"./component\";\n\nexport const popperProps = {\n  ...componentProps,\n  content: {\n    type: String,\n    default: null,\n  },\n};\n\nexport const setupPopper = (props, leafletRef) => {\n  const { options, methods: componentMethods } = setupComponent(props);\n\n  const methods = {\n    ...componentMethods,\n    setContent(newVal) {\n      if (leafletRef.value && newVal !== null && newVal !== undefined) {\n        leafletRef.value.setContent(newVal);\n      }\n    },\n  };\n\n  return { options, methods };\n};\n\nexport const render = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n  return null;\n};\n","import { onBeforeUnmount, inject } from \"vue\";\nimport { popperProps, setupPopper } from \"./popper\";\n\nexport const popupProps = {\n  ...popperProps,\n  latLng: {\n    type: [Object, Array],\n    default: () => [],\n  },\n};\n\nexport const setupPopup = (props, leafletRef) => {\n  const { options, methods } = setupPopper(props, leafletRef);\n\n  const unbindPopup = inject(\"unbindPopup\");\n\n  onBeforeUnmount(() => {\n    unbindPopup();\n  });\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  propsBinder,\n  remapEvents,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { popupProps, setupPopup } from \"../functions/popup\";\nimport { render } from \"../functions/popper\";\n\n/**\n * Display a popup on the map\n */\nexport default {\n  name: \"LPopup\",\n  props: popupProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindPopup = inject(\"bindPopup\");\n\n    const { options, methods } = setupPopup(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { popup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = popup(options);\n\n      if (props.latLng !== undefined) {\n        leafletRef.value.setLatLng(props.latLng);\n      }\n\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindPopup({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.$slots);\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { polygonProps, setupPolygon } from \"./polygon\";\n\npolygonProps.latLngs.required = false;\nexport const rectangleProps = {\n  ...polygonProps,\n  bounds: {\n    type: Array,\n    custom: true,\n  },\n};\n\nexport const setupRectangle = (props, leafletRef, context) => {\n  const { options: polygonOptions, methods: polygonMethods } = setupPolygon(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = propsToLeafletOptions(props, rectangleProps, polygonOptions);\n\n  const methods = {\n    ...polygonMethods,\n    setBounds(latLngBounds) {\n      leafletRef.value.setBounds(latLngBounds);\n    },\n    setLatLngs(latLngs) {\n      // Calling setLatLngs on a Leaflet rectangle will convert it\n      // to a polygon. So instead, we call setBounds here to ensure\n      // that the rectangle remains a rectangle, defined by the\n      // bounds of the points in the latLngs array.\n      leafletRef.value.setBounds(latLngs);\n    },\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { rectangleProps, setupRectangle } from \"../functions/rectangle\";\nimport { render } from \"../functions/layer\";\n\n/**\n * Rectangle component, lets you add and customize rectangular regions on the map\n */\nexport default {\n  name: \"LRectangle\",\n  props: rectangleProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setupRectangle(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { rectangle, latLngBounds, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      const bounds =\n        props.bounds && props.bounds.length\n          ? latLngBounds(props.bounds)\n          : latLngBounds(props.latLngs);\n      leafletRef.value = rectangle(bounds, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { gridLayerProps, setupGridLayer } from \"./gridLayer\";\n\nexport const tileLayerProps = {\n  ...gridLayerProps,\n  tms: {\n    type: Boolean,\n    default: undefined,\n  },\n  subdomains: {\n    type: String,\n  },\n  detectRetina: {\n    type: Boolean,\n    default: undefined,\n  },\n  url: {\n    type: String,\n    required: true,\n    custom: true,\n  },\n};\n\nexport const setupTileLayer = (props, leafletRef, context) => {\n  const {\n    options: gridLayerOptions,\n    methods: gridLayerMethods,\n  } = setupGridLayer(props, leafletRef, context);\n\n  const options = propsToLeafletOptions(\n    props,\n    tileLayerProps,\n    gridLayerOptions\n  );\n\n  const methods = {\n    ...gridLayerMethods,\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { tileLayerProps, setupTileLayer } from \"../functions/tileLayer\";\n\nexport default {\n  props: tileLayerProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setupTileLayer(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { tileLayer, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = tileLayer(props.url, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { leafletObject: leafletRef };\n  },\n  render() {\n    return null;\n  },\n};\n</script>\n","import { onBeforeUnmount, inject } from \"vue\";\nimport { popperProps, setupPopper } from \"./popper\";\n\nexport const tooltipProps = {\n  ...popperProps,\n};\n\nexport const setupTooltip = (props, leafletRef) => {\n  const { options, methods } = setupPopper(props, leafletRef);\n\n  const unbindTooltip = inject(\"unbindTooltip\");\n\n  onBeforeUnmount(() => {\n    unbindTooltip();\n  });\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  propsBinder,\n  remapEvents,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { tooltipProps, setupTooltip } from \"../functions/tooltip\";\nimport { render } from \"../functions/popper\";\n\n/**\n * Display a tooltip on the map\n */\nexport default {\n  name: \"LTooltip\",\n  props: tooltipProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindTooltip = inject(\"bindTooltip\");\n\n    const { options, methods } = setupTooltip(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { tooltip, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = tooltip(options);\n\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindTooltip({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.$slots);\n  },\n};\n</script>\n","import { propsToLeafletOptions } from \"../utils\";\nimport { tileLayerProps, setupTileLayer } from \"./tileLayer\";\n\nexport const wmsTileLayerProps = {\n  ...tileLayerProps,\n  layers: {\n    type: String,\n    required: true,\n  },\n  styles: {\n    type: String,\n  },\n  format: {\n    type: String,\n  },\n  transparent: {\n    type: Boolean,\n    default: undefined,\n  },\n  version: {\n    type: String,\n  },\n  crs: {\n    type: Object,\n  },\n  upperCase: {\n    type: Boolean,\n    default: undefined,\n  },\n};\n\nexport const setupWMSTileLayer = (props, leafletRef) => {\n  const {\n    options: tileLayerOptions,\n    methods: tileLayerMethods,\n  } = setupTileLayer(props, leafletRef);\n\n  const options = propsToLeafletOptions(\n    props,\n    wmsTileLayerProps,\n    tileLayerOptions\n  );\n\n  return {\n    options,\n    methods: {\n      ...tileLayerMethods,\n    },\n  };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport {\n  wmsTileLayerProps,\n  setupWMSTileLayer,\n} from \"../functions/wmsTileLayer\";\n\nexport default {\n  props: wmsTileLayerProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setupWMSTileLayer(props, leafletRef);\n\n    onMounted(async () => {\n      const { tileLayer, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = tileLayer.wms(props.url, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}