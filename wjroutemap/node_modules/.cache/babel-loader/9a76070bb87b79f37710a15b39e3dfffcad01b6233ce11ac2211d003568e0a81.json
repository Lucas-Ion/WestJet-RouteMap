{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { computed, h, nextTick, onBeforeUnmount, onMounted, provide, reactive, ref } from \"vue\";\nimport { remapEvents, propsBinder, debounce, resetWebpackIcon, provideLeafletWrapper, updateLeafletWrapper, WINDOW_OR_GLOBAL, GLOBAL_LEAFLET_OPT, propsToLeafletOptions } from \"../utils.js\";\nimport { componentProps, setupComponent } from \"../functions/component\";\nconst mapProps = {\n  ...componentProps,\n  /**\n   * The center of the map, supports .sync modifier\n   */\n  center: {\n    type: [Object, Array]\n  },\n  /**\n   * The bounds of the map, supports .sync modifier\n   */\n  bounds: {\n    type: [Array, Object]\n  },\n  /**\n   * The max bounds of the map\n   */\n  maxBounds: {\n    type: [Array, Object]\n  },\n  /**\n   * The zoom of the map, supports .sync modifier\n   */\n  zoom: {\n    type: Number\n  },\n  /**\n   * The minZoom of the map\n   */\n  minZoom: {\n    type: Number\n  },\n  /**\n   * The maxZoom of the map\n   */\n  maxZoom: {\n    type: Number\n  },\n  /**\n   * The paddingBottomRight of the map\n   */\n  paddingBottomRight: {\n    type: Array\n  },\n  /**\n   * The paddingTopLeft of the map\n   */\n  paddingTopLeft: {\n    type: Array\n  },\n  /**\n   * The padding of the map\n   */\n  padding: {\n    type: Array\n  },\n  /**\n   * The worldCopyJump option for the map\n   */\n  worldCopyJump: {\n    type: Boolean,\n    default: undefined\n  },\n  /**\n   * The CRS to use for the map. Can be an object that defines a coordinate reference\n   * system for projecting geographical points into screen coordinates and back\n   * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string\n   * name identifying one of Leaflet's defined CRSs, such as \"EPSG4326\".\n   */\n  crs: {\n    type: [String, Object]\n  },\n  maxBoundsViscosity: {\n    type: Number\n  },\n  inertia: {\n    type: Boolean,\n    default: undefined\n  },\n  inertiaDeceleration: {\n    type: Number\n  },\n  inertiaMaxSpeed: {\n    type: Number\n  },\n  easeLinearity: {\n    type: Number\n  },\n  zoomAnimation: {\n    type: Boolean,\n    default: undefined\n  },\n  zoomAnimationThreshold: {\n    type: Number\n  },\n  fadeAnimation: {\n    type: Boolean,\n    default: undefined\n  },\n  markerZoomAnimation: {\n    type: Boolean,\n    default: undefined\n  },\n  noBlockingAnimations: {\n    type: Boolean,\n    default: undefined\n  },\n  useGlobalLeaflet: {\n    type: Boolean,\n    default: undefined\n  }\n};\nexport default {\n  emits: [\"ready\", \"update:zoom\", \"update:center\", \"update:bounds\"],\n  props: mapProps,\n  setup(props, context) {\n    const root = ref(null);\n    const blueprint = reactive({\n      ready: false,\n      leafletRef: {},\n      layersToAdd: [],\n      layersInControl: []\n    });\n    const {\n      options: componentOptions\n    } = setupComponent(props);\n    const options = propsToLeafletOptions(props, mapProps, componentOptions);\n    const addLayer = provideLeafletWrapper(\"addLayer\");\n    const removeLayer = provideLeafletWrapper(\"removeLayer\");\n    const registerControl = provideLeafletWrapper(\"registerControl\");\n    const registerLayerControl = provideLeafletWrapper(\"registerLayerControl\");\n    provide(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);\n    const eventHandlers = {\n      moveEndHandler() {\n        /**\n         * Triggers when zoom is updated\n         * @type {number,string}\n         */\n        context.emit(\"update:zoom\", blueprint.leafletRef.getZoom());\n        /**\n         * Triggers when center is updated\n         * @type {object,array}\n         */\n        context.emit(\"update:center\", blueprint.leafletRef.getCenter());\n\n        /**\n         * Triggers when bounds are updated\n         * @type {object}\n         */\n        context.emit(\"update:bounds\", blueprint.leafletRef.getBounds());\n      },\n      overlayAddHandler(e) {\n        const layer = blueprint.layersInControl.find(l => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(true);\n        }\n      },\n      overlayRemoveHandler(e) {\n        const layer = blueprint.layersInControl.find(l => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(false);\n        }\n      }\n    };\n    onMounted(async () => {\n      if (props.useGlobalLeaflet) {\n        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await import(\"leaflet\"));\n      }\n      const {\n        map,\n        CRS,\n        Icon,\n        latLngBounds,\n        latLng,\n        DomEvent\n      } = props.useGlobalLeaflet ? WINDOW_OR_GLOBAL.L : await import(\"leaflet/dist/leaflet-src.esm\");\n      try {\n        options.beforeMapMount && (await options.beforeMapMount());\n      } catch (error) {\n        console.error(`The following error occurred running the provided beforeMapMount hook ${error.message}`);\n      }\n      await resetWebpackIcon(Icon);\n      const optionsCrs = typeof options.crs == \"string\" ? CRS[options.crs] : options.crs;\n      options.crs = optionsCrs || CRS.EPSG3857;\n      const methods = {\n        addLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd.push(layer);\n            } else {\n              const exist = blueprint.layersInControl.find(l => l.leafletObject._leaflet_id === layer.leafletObject._leaflet_id);\n              if (!exist) {\n                blueprint.layerControl.addLayer(layer);\n                blueprint.layersInControl.push(layer);\n              }\n            }\n          }\n          if (layer.visible !== false) {\n            blueprint.leafletRef.addLayer(layer.leafletObject);\n          }\n        },\n        removeLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd = blueprint.layersToAdd.filter(l => l.name !== layer.name);\n            } else {\n              blueprint.layerControl.removeLayer(layer.leafletObject);\n              blueprint.layersInControl = blueprint.layersInControl.filter(l => l.leafletObject._leaflet_id !== layer.leafletObject._leaflet_id);\n            }\n          }\n          blueprint.leafletRef.removeLayer(layer.leafletObject);\n        },\n        registerLayerControl(lControlLayer) {\n          blueprint.layerControl = lControlLayer;\n          blueprint.layersToAdd.forEach(layer => {\n            blueprint.layerControl.addLayer(layer);\n          });\n          blueprint.layersToAdd = [];\n          registerControl(lControlLayer);\n        },\n        registerControl(lControl) {\n          blueprint.leafletRef.addControl(lControl.leafletObject);\n        },\n        setZoom(newVal) {\n          const zoom = blueprint.leafletRef.getZoom();\n          if (newVal !== zoom) {\n            blueprint.leafletRef.setZoom(newVal, {\n              animate: props.noBlockingAnimations ? false : null\n            });\n          }\n        },\n        setPaddingBottomRight(newVal) {\n          blueprint.paddingBottomRight = newVal;\n        },\n        setPaddingTopLeft(newVal) {\n          blueprint.paddingTopLeft = newVal;\n        },\n        setPadding(newVal) {\n          blueprint.padding = newVal;\n        },\n        setCrs(newVal) {\n          const prevBounds = blueprint.leafletRef.getBounds();\n          blueprint.leafletRef.options.crs = newVal;\n          blueprint.leafletRef.fitBounds(prevBounds, {\n            animate: false,\n            padding: [0, 0]\n          });\n        },\n        fitBounds(bounds) {\n          blueprint.leafletRef.fitBounds(bounds, {\n            animate: this.noBlockingAnimations ? false : null\n          });\n        },\n        setBounds(newVal) {\n          if (!newVal) {\n            return;\n          }\n          const newBounds = latLngBounds(newVal);\n          if (!newBounds.isValid()) {\n            return;\n          }\n          const oldBounds = blueprint.lastSetBounds || blueprint.leafletRef.getBounds();\n          const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals\n          if (boundsChanged) {\n            blueprint.lastSetBounds = newBounds;\n            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);\n          }\n        },\n        setCenter(newVal) {\n          if (newVal == null) {\n            return;\n          }\n          const newCenter = latLng(newVal);\n          const oldCenter = blueprint.lastSetCenter || blueprint.leafletRef.getCenter();\n          if (oldCenter.lat !== newCenter.lat || oldCenter.lng !== newCenter.lng) {\n            blueprint.lastSetCenter = newCenter;\n            blueprint.leafletRef.panTo(newCenter, {\n              animate: this.noBlockingAnimations ? false : null\n            });\n          }\n        }\n      };\n      updateLeafletWrapper(addLayer, methods.addLayer);\n      updateLeafletWrapper(removeLayer, methods.removeLayer);\n      updateLeafletWrapper(registerControl, methods.registerControl);\n      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);\n      blueprint.leafletRef = map(root.value, options);\n      propsBinder(methods, blueprint.leafletRef, props);\n      const listeners = remapEvents(context.attrs);\n      blueprint.leafletRef.on(\"moveend\", debounce(eventHandlers.moveEndHandler, 100));\n      blueprint.leafletRef.on(\"overlayadd\", eventHandlers.overlayAddHandler);\n      blueprint.leafletRef.on(\"overlayremove\", eventHandlers.overlayRemoveHandler);\n      DomEvent.on(blueprint.leafletRef, listeners);\n      blueprint.ready = true;\n      nextTick(() => context.emit(\"ready\", blueprint.leafletRef));\n    });\n    onBeforeUnmount(() => {\n      if (blueprint.leafletRef) {\n        blueprint.leafletRef.off();\n        blueprint.leafletRef.remove();\n      }\n    });\n    const leafletObject = computed(() => blueprint.leafletRef);\n    const ready = computed(() => blueprint.ready);\n    return {\n      root,\n      ready,\n      leafletObject\n    };\n  },\n  render() {\n    return h(\"div\", {\n      style: {\n        width: \"100%\",\n        height: \"100%\"\n      },\n      ref: \"root\"\n    }, this.ready ? this.$slots.default() : {});\n  }\n};","map":{"version":3,"mappings":"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","names":["computed","h","nextTick","onBeforeUnmount","onMounted","provide","reactive","ref","remapEvents","propsBinder","debounce","resetWebpackIcon","provideLeafletWrapper","updateLeafletWrapper","WINDOW_OR_GLOBAL","GLOBAL_LEAFLET_OPT","propsToLeafletOptions","componentProps","setupComponent","mapProps","center","type","Object","Array","bounds","maxBounds","zoom","Number","minZoom","maxZoom","paddingBottomRight","paddingTopLeft","padding","worldCopyJump","Boolean","default","undefined","crs","String","maxBoundsViscosity","inertia","inertiaDeceleration","inertiaMaxSpeed","easeLinearity","zoomAnimation","zoomAnimationThreshold","fadeAnimation","markerZoomAnimation","noBlockingAnimations","useGlobalLeaflet","emits","props","setup","context","root","blueprint","ready","leafletRef","layersToAdd","layersInControl","options","componentOptions","addLayer","removeLayer","registerControl","registerLayerControl","eventHandlers","moveEndHandler","emit","getZoom","getCenter","getBounds","overlayAddHandler","e","layer","find","l","name","updateVisibleProp","overlayRemoveHandler","L","map","CRS","Icon","latLngBounds","latLng","DomEvent","beforeMapMount","error","console","message","optionsCrs","EPSG3857","methods","layerType","layerControl","push","exist","leafletObject","_leaflet_id","visible","filter","lControlLayer","forEach","lControl","addControl","setZoom","newVal","animate","setPaddingBottomRight","setPaddingTopLeft","setPadding","setCrs","prevBounds","fitBounds","setBounds","newBounds","isValid","oldBounds","lastSetBounds","boundsChanged","equals","fitBoundsOptions","setCenter","newCenter","oldCenter","lastSetCenter","lat","lng","panTo","value","listeners","attrs","on","off","remove","render","style","width","height","$slots"],"sourceRoot":"","sources":["/Users/lucasion/Desktop/Capstone/WestJet-RouteMap/wjroutemap/node_modules/@vue-leaflet/vue-leaflet/src/components/LMap.vue"],"sourcesContent":["<script>\nimport {\n  computed,\n  h,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n} from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  debounce,\n  resetWebpackIcon,\n  provideLeafletWrapper,\n  updateLeafletWrapper,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n  propsToLeafletOptions,\n} from \"../utils.js\";\nimport { componentProps, setupComponent } from \"../functions/component\";\n\nconst mapProps = {\n  ...componentProps,\n  /**\n   * The center of the map, supports .sync modifier\n   */\n  center: {\n    type: [Object, Array],\n  },\n  /**\n   * The bounds of the map, supports .sync modifier\n   */\n  bounds: {\n    type: [Array, Object],\n  },\n  /**\n   * The max bounds of the map\n   */\n  maxBounds: {\n    type: [Array, Object],\n  },\n  /**\n   * The zoom of the map, supports .sync modifier\n   */\n  zoom: {\n    type: Number,\n  },\n  /**\n   * The minZoom of the map\n   */\n  minZoom: {\n    type: Number,\n  },\n  /**\n   * The maxZoom of the map\n   */\n  maxZoom: {\n    type: Number,\n  },\n  /**\n   * The paddingBottomRight of the map\n   */\n  paddingBottomRight: {\n    type: Array,\n  },\n  /**\n   * The paddingTopLeft of the map\n   */\n  paddingTopLeft: {\n    type: Array,\n  },\n  /**\n   * The padding of the map\n   */\n  padding: {\n    type: Array,\n  },\n  /**\n   * The worldCopyJump option for the map\n   */\n  worldCopyJump: {\n    type: Boolean,\n    default: undefined,\n  },\n  /**\n   * The CRS to use for the map. Can be an object that defines a coordinate reference\n   * system for projecting geographical points into screen coordinates and back\n   * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string\n   * name identifying one of Leaflet's defined CRSs, such as \"EPSG4326\".\n   */\n  crs: {\n    type: [String, Object],\n  },\n  maxBoundsViscosity: {\n    type: Number,\n  },\n  inertia: {\n    type: Boolean,\n    default: undefined,\n  },\n  inertiaDeceleration: {\n    type: Number,\n  },\n  inertiaMaxSpeed: {\n    type: Number,\n  },\n  easeLinearity: {\n    type: Number,\n  },\n  zoomAnimation: {\n    type: Boolean,\n    default: undefined,\n  },\n  zoomAnimationThreshold: {\n    type: Number,\n  },\n  fadeAnimation: {\n    type: Boolean,\n    default: undefined,\n  },\n  markerZoomAnimation: {\n    type: Boolean,\n    default: undefined,\n  },\n  noBlockingAnimations: {\n    type: Boolean,\n    default: undefined,\n  },\n  useGlobalLeaflet: {\n    type: Boolean,\n    default: undefined,\n  },\n};\n\nexport default {\n  emits: [\"ready\", \"update:zoom\", \"update:center\", \"update:bounds\"],\n  props: mapProps,\n  setup(props, context) {\n    const root = ref(null);\n    const blueprint = reactive({\n      ready: false,\n      leafletRef: {},\n      layersToAdd: [],\n      layersInControl: [],\n    });\n\n    const { options: componentOptions } = setupComponent(props);\n\n    const options = propsToLeafletOptions(props, mapProps, componentOptions);\n\n    const addLayer = provideLeafletWrapper(\"addLayer\");\n    const removeLayer = provideLeafletWrapper(\"removeLayer\");\n    const registerControl = provideLeafletWrapper(\"registerControl\");\n    const registerLayerControl = provideLeafletWrapper(\"registerLayerControl\");\n    provide(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);\n\n    const eventHandlers = {\n      moveEndHandler() {\n        /**\n         * Triggers when zoom is updated\n         * @type {number,string}\n         */\n        context.emit(\"update:zoom\", blueprint.leafletRef.getZoom());\n        /**\n         * Triggers when center is updated\n         * @type {object,array}\n         */\n        context.emit(\"update:center\", blueprint.leafletRef.getCenter());\n\n        /**\n         * Triggers when bounds are updated\n         * @type {object}\n         */\n        context.emit(\"update:bounds\", blueprint.leafletRef.getBounds());\n      },\n      overlayAddHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(true);\n        }\n      },\n      overlayRemoveHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(false);\n        }\n      },\n    };\n\n    onMounted(async () => {\n      if (props.useGlobalLeaflet) {\n        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await import(\"leaflet\"));\n      }\n      const {\n        map,\n        CRS,\n        Icon,\n        latLngBounds,\n        latLng,\n        DomEvent,\n      } = props.useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      try {\n        options.beforeMapMount && (await options.beforeMapMount());\n      } catch (error) {\n        console.error(\n          `The following error occurred running the provided beforeMapMount hook ${error.message}`\n        );\n      }\n\n      await resetWebpackIcon(Icon);\n\n      const optionsCrs =\n        typeof options.crs == \"string\" ? CRS[options.crs] : options.crs;\n      options.crs = optionsCrs || CRS.EPSG3857;\n\n      const methods = {\n        addLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd.push(layer);\n            } else {\n              const exist = blueprint.layersInControl.find(\n                (l) =>\n                  l.leafletObject._leaflet_id ===\n                  layer.leafletObject._leaflet_id\n              );\n              if (!exist) {\n                blueprint.layerControl.addLayer(layer);\n                blueprint.layersInControl.push(layer);\n              }\n            }\n          }\n          if (layer.visible !== false) {\n            blueprint.leafletRef.addLayer(layer.leafletObject);\n          }\n        },\n        removeLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd = blueprint.layersToAdd.filter(\n                (l) => l.name !== layer.name\n              );\n            } else {\n              blueprint.layerControl.removeLayer(layer.leafletObject);\n              blueprint.layersInControl = blueprint.layersInControl.filter(\n                (l) =>\n                  l.leafletObject._leaflet_id !==\n                  layer.leafletObject._leaflet_id\n              );\n            }\n          }\n          blueprint.leafletRef.removeLayer(layer.leafletObject);\n        },\n\n        registerLayerControl(lControlLayer) {\n          blueprint.layerControl = lControlLayer;\n          blueprint.layersToAdd.forEach((layer) => {\n            blueprint.layerControl.addLayer(layer);\n          });\n          blueprint.layersToAdd = [];\n\n          registerControl(lControlLayer);\n        },\n\n        registerControl(lControl) {\n          blueprint.leafletRef.addControl(lControl.leafletObject);\n        },\n\n        setZoom(newVal) {\n          const zoom = blueprint.leafletRef.getZoom();\n          if (newVal !== zoom) {\n            blueprint.leafletRef.setZoom(newVal, {\n              animate: props.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n\n        setPaddingBottomRight(newVal) {\n          blueprint.paddingBottomRight = newVal;\n        },\n        setPaddingTopLeft(newVal) {\n          blueprint.paddingTopLeft = newVal;\n        },\n        setPadding(newVal) {\n          blueprint.padding = newVal;\n        },\n        setCrs(newVal) {\n          const prevBounds = blueprint.leafletRef.getBounds();\n          blueprint.leafletRef.options.crs = newVal;\n          blueprint.leafletRef.fitBounds(prevBounds, {\n            animate: false,\n            padding: [0, 0],\n          });\n        },\n        fitBounds(bounds) {\n          blueprint.leafletRef.fitBounds(bounds, {\n            animate: this.noBlockingAnimations ? false : null,\n          });\n        },\n        setBounds(newVal) {\n          if (!newVal) {\n            return;\n          }\n          const newBounds = latLngBounds(newVal);\n          if (!newBounds.isValid()) {\n            return;\n          }\n          const oldBounds =\n            blueprint.lastSetBounds || blueprint.leafletRef.getBounds();\n          const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals\n          if (boundsChanged) {\n            blueprint.lastSetBounds = newBounds;\n            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);\n          }\n        },\n\n        setCenter(newVal) {\n          if (newVal == null) {\n            return;\n          }\n          const newCenter = latLng(newVal);\n          const oldCenter =\n            blueprint.lastSetCenter || blueprint.leafletRef.getCenter();\n          if (\n            oldCenter.lat !== newCenter.lat ||\n            oldCenter.lng !== newCenter.lng\n          ) {\n            blueprint.lastSetCenter = newCenter;\n            blueprint.leafletRef.panTo(newCenter, {\n              animate: this.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n      };\n\n      updateLeafletWrapper(addLayer, methods.addLayer);\n      updateLeafletWrapper(removeLayer, methods.removeLayer);\n      updateLeafletWrapper(registerControl, methods.registerControl);\n      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);\n\n      blueprint.leafletRef = map(root.value, options);\n\n      propsBinder(methods, blueprint.leafletRef, props);\n      const listeners = remapEvents(context.attrs);\n\n      blueprint.leafletRef.on(\n        \"moveend\",\n        debounce(eventHandlers.moveEndHandler, 100)\n      );\n      blueprint.leafletRef.on(\"overlayadd\", eventHandlers.overlayAddHandler);\n      blueprint.leafletRef.on(\n        \"overlayremove\",\n        eventHandlers.overlayRemoveHandler\n      );\n      DomEvent.on(blueprint.leafletRef, listeners);\n      blueprint.ready = true;\n      nextTick(() => context.emit(\"ready\", blueprint.leafletRef));\n    });\n\n    onBeforeUnmount(() => {\n      if (blueprint.leafletRef) {\n        blueprint.leafletRef.off();\n        blueprint.leafletRef.remove();\n      }\n    });\n\n    const leafletObject = computed(() => blueprint.leafletRef);\n    const ready = computed(() => blueprint.ready);\n    return { root, ready, leafletObject };\n  },\n  render() {\n    return h(\n      \"div\",\n      { style: { width: \"100%\", height: \"100%\" }, ref: \"root\" },\n      this.ready ? this.$slots.default() : {}\n    );\n  },\n};\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}