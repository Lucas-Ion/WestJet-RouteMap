{"ast":null,"code":"import { watch, ref, provide } from \"vue\";\nexport const debounce = (fn, time) => {\n  let timeout;\n  return function (...args) {\n    const context = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.apply(context, args);\n      timeout = null;\n    }, time);\n  };\n};\nexport const capitalizeFirstLetter = string => {\n  if (!string || typeof string.charAt !== \"function\") {\n    return string;\n  }\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\nexport const isFunction = x => typeof x === \"function\";\nexport const propsBinder = (methods, leafletElement, props) => {\n  for (const key in props) {\n    const setMethodName = \"set\" + capitalizeFirstLetter(key);\n    if (methods[setMethodName]) {\n      watch(() => props[key], (newVal, oldVal) => {\n        methods[setMethodName](newVal, oldVal);\n      });\n    } else if (leafletElement[setMethodName]) {\n      watch(() => props[key], newVal => {\n        leafletElement[setMethodName](newVal);\n      });\n    }\n  }\n};\nexport const propsToLeafletOptions = (propValues, propDefinitions, baseOptions = {}) => {\n  const output = {\n    ...baseOptions\n  };\n  for (const prop in propValues) {\n    const defn = propDefinitions[prop];\n    const val = propValues[prop];\n\n    // Unexpected props should not be converted to Leaflet options.\n    if (!defn) continue;\n    // Custom vue-leaflet props should not be passed to Leaflet.\n    if (defn && defn.custom === true) continue;\n    // Exclude undefined values so that Leaflet uses its own defaults.\n    if (val === undefined) continue;\n    output[prop] = val;\n  }\n  return output;\n};\nexport const remapEvents = contextAttrs => {\n  const result = {};\n  for (const attrName in contextAttrs) {\n    if (attrName.startsWith(\"on\") && !attrName.startsWith(\"onUpdate\") && attrName !== \"onReady\") {\n      const eventName = attrName.slice(2).toLocaleLowerCase();\n      result[eventName] = contextAttrs[attrName];\n    }\n  }\n  return result;\n};\nexport const resetWebpackIcon = async Icon => {\n  const modules = await Promise.all([import(\"leaflet/dist/images/marker-icon-2x.png\"), import(\"leaflet/dist/images/marker-icon.png\"), import(\"leaflet/dist/images/marker-shadow.png\")]);\n  delete Icon.Default.prototype._getIconUrl;\n  Icon.Default.mergeOptions({\n    iconRetinaUrl: modules[0].default,\n    iconUrl: modules[1].default,\n    shadowUrl: modules[2].default\n  });\n};\n\n/**\n * Wraps a placeholder function and provides it with the given name.\n * The wrapper can later be updated with {@link updateLeafletWrapper}\n * to provide a different function.\n *\n * @param {String} methodName Key used to provide the wrapper function\n */\nexport const provideLeafletWrapper = methodName => {\n  const wrapped = ref(() => console.warn(`Method ${methodName} has been invoked without being replaced`));\n  const wrapper = (...args) => wrapped.value(...args);\n  // eslint-disable-next-line vue/no-ref-as-operand\n  wrapper.wrapped = wrapped;\n  provide(methodName, wrapper);\n  return wrapper;\n};\n\n/**\n * Change the function that will be executed when an injected Leaflet wrapper\n * is invoked.\n *\n * @param {*} wrapper Provided wrapper whose wrapped function is to be updated\n * @param {function} leafletMethod New method to be wrapped by the wrapper\n */\nexport const updateLeafletWrapper = (wrapper, leafletMethod) => wrapper.wrapped.value = leafletMethod;\nexport const WINDOW_OR_GLOBAL = typeof self === \"object\" && self.self === self && self || typeof global === \"object\" && global.global === global && global || undefined;\nexport const GLOBAL_LEAFLET_OPT = \"useGlobalLeaflet\";","map":{"version":3,"names":["watch","ref","provide","debounce","fn","time","timeout","args","context","clearTimeout","setTimeout","apply","capitalizeFirstLetter","string","charAt","toUpperCase","slice","isFunction","x","propsBinder","methods","leafletElement","props","key","setMethodName","newVal","oldVal","propsToLeafletOptions","propValues","propDefinitions","baseOptions","output","prop","defn","val","custom","undefined","remapEvents","contextAttrs","result","attrName","startsWith","eventName","toLocaleLowerCase","resetWebpackIcon","Icon","modules","Promise","all","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","default","iconUrl","shadowUrl","provideLeafletWrapper","methodName","wrapped","console","warn","wrapper","value","updateLeafletWrapper","leafletMethod","WINDOW_OR_GLOBAL","self","global","GLOBAL_LEAFLET_OPT"],"sources":["/Users/lucasion/Desktop/Capstone/WestJet-RouteMap/wjroutemap/node_modules/@vue-leaflet/vue-leaflet/src/utils.js"],"sourcesContent":["import { watch, ref, provide } from \"vue\";\n\nexport const debounce = (fn, time) => {\n  let timeout;\n\n  return function (...args) {\n    const context = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.apply(context, args);\n      timeout = null;\n    }, time);\n  };\n};\n\nexport const capitalizeFirstLetter = (string) => {\n  if (!string || typeof string.charAt !== \"function\") {\n    return string;\n  }\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nexport const isFunction = (x) => typeof x === \"function\";\n\nexport const propsBinder = (methods, leafletElement, props) => {\n  for (const key in props) {\n    const setMethodName = \"set\" + capitalizeFirstLetter(key);\n    if (methods[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal, oldVal) => {\n          methods[setMethodName](newVal, oldVal);\n        }\n      );\n    } else if (leafletElement[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal) => {\n          leafletElement[setMethodName](newVal);\n        }\n      );\n    }\n  }\n};\n\nexport const propsToLeafletOptions = (\n  propValues,\n  propDefinitions,\n  baseOptions = {}\n) => {\n  const output = { ...baseOptions };\n\n  for (const prop in propValues) {\n    const defn = propDefinitions[prop];\n    const val = propValues[prop];\n\n    // Unexpected props should not be converted to Leaflet options.\n    if (!defn) continue;\n    // Custom vue-leaflet props should not be passed to Leaflet.\n    if (defn && defn.custom === true) continue;\n    // Exclude undefined values so that Leaflet uses its own defaults.\n    if (val === undefined) continue;\n\n    output[prop] = val;\n  }\n\n  return output;\n};\n\nexport const remapEvents = (contextAttrs) => {\n  const result = {};\n  for (const attrName in contextAttrs) {\n    if (\n      attrName.startsWith(\"on\") &&\n      !attrName.startsWith(\"onUpdate\") &&\n      attrName !== \"onReady\"\n    ) {\n      const eventName = attrName.slice(2).toLocaleLowerCase();\n      result[eventName] = contextAttrs[attrName];\n    }\n  }\n  return result;\n};\n\nexport const resetWebpackIcon = async (Icon) => {\n  const modules = await Promise.all([\n    import(\"leaflet/dist/images/marker-icon-2x.png\"),\n    import(\"leaflet/dist/images/marker-icon.png\"),\n    import(\"leaflet/dist/images/marker-shadow.png\"),\n  ]);\n\n  delete Icon.Default.prototype._getIconUrl;\n\n  Icon.Default.mergeOptions({\n    iconRetinaUrl: modules[0].default,\n    iconUrl: modules[1].default,\n    shadowUrl: modules[2].default,\n  });\n};\n\n/**\n * Wraps a placeholder function and provides it with the given name.\n * The wrapper can later be updated with {@link updateLeafletWrapper}\n * to provide a different function.\n *\n * @param {String} methodName Key used to provide the wrapper function\n */\nexport const provideLeafletWrapper = (methodName) => {\n  const wrapped = ref(() =>\n    console.warn(`Method ${methodName} has been invoked without being replaced`)\n  );\n  const wrapper = (...args) => wrapped.value(...args);\n  // eslint-disable-next-line vue/no-ref-as-operand\n  wrapper.wrapped = wrapped;\n  provide(methodName, wrapper);\n\n  return wrapper;\n};\n\n/**\n * Change the function that will be executed when an injected Leaflet wrapper\n * is invoked.\n *\n * @param {*} wrapper Provided wrapper whose wrapped function is to be updated\n * @param {function} leafletMethod New method to be wrapped by the wrapper\n */\nexport const updateLeafletWrapper = (wrapper, leafletMethod) =>\n  (wrapper.wrapped.value = leafletMethod);\n\nexport const WINDOW_OR_GLOBAL =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  undefined;\n\nexport const GLOBAL_LEAFLET_OPT = \"useGlobalLeaflet\";\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}