(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['vue-leaflet'] = {}, global.vue));
}(this, (function (exports, vue) { 'use strict';

  const debounce = (fn, time) => {
    let timeout;

    return function (...args) {
      const context = this;
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        fn.apply(context, args);
        timeout = null;
      }, time);
    };
  };

  const capitalizeFirstLetter = (string) => {
    if (!string || typeof string.charAt !== "function") {
      return string;
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
  };

  const isFunction = (x) => typeof x === "function";

  const propsBinder = (methods, leafletElement, props) => {
    for (const key in props) {
      const setMethodName = "set" + capitalizeFirstLetter(key);
      if (methods[setMethodName]) {
        vue.watch(
          () => props[key],
          (newVal, oldVal) => {
            methods[setMethodName](newVal, oldVal);
          }
        );
      } else if (leafletElement[setMethodName]) {
        vue.watch(
          () => props[key],
          (newVal) => {
            leafletElement[setMethodName](newVal);
          }
        );
      }
    }
  };

  const propsToLeafletOptions = (
    propValues,
    propDefinitions,
    baseOptions = {}
  ) => {
    const output = { ...baseOptions };

    for (const prop in propValues) {
      const defn = propDefinitions[prop];
      const val = propValues[prop];

      // Unexpected props should not be converted to Leaflet options.
      if (!defn) continue;
      // Custom vue-leaflet props should not be passed to Leaflet.
      if (defn && defn.custom === true) continue;
      // Exclude undefined values so that Leaflet uses its own defaults.
      if (val === undefined) continue;

      output[prop] = val;
    }

    return output;
  };

  const remapEvents = (contextAttrs) => {
    const result = {};
    for (const attrName in contextAttrs) {
      if (
        attrName.startsWith("on") &&
        !attrName.startsWith("onUpdate") &&
        attrName !== "onReady"
      ) {
        const eventName = attrName.slice(2).toLocaleLowerCase();
        result[eventName] = contextAttrs[attrName];
      }
    }
    return result;
  };

  const resetWebpackIcon = async (Icon) => {
    const modules = await Promise.all([
      import('leaflet/dist/images/marker-icon-2x.png'),
      import('leaflet/dist/images/marker-icon.png'),
      import('leaflet/dist/images/marker-shadow.png'),
    ]);

    delete Icon.Default.prototype._getIconUrl;

    Icon.Default.mergeOptions({
      iconRetinaUrl: modules[0].default,
      iconUrl: modules[1].default,
      shadowUrl: modules[2].default,
    });
  };

  /**
   * Wraps a placeholder function and provides it with the given name.
   * The wrapper can later be updated with {@link updateLeafletWrapper}
   * to provide a different function.
   *
   * @param {String} methodName Key used to provide the wrapper function
   */
  const provideLeafletWrapper = (methodName) => {
    const wrapped = vue.ref(() =>
      console.warn(`Method ${methodName} has been invoked without being replaced`)
    );
    const wrapper = (...args) => wrapped.value(...args);
    // eslint-disable-next-line vue/no-ref-as-operand
    wrapper.wrapped = wrapped;
    vue.provide(methodName, wrapper);

    return wrapper;
  };

  /**
   * Change the function that will be executed when an injected Leaflet wrapper
   * is invoked.
   *
   * @param {*} wrapper Provided wrapper whose wrapped function is to be updated
   * @param {function} leafletMethod New method to be wrapped by the wrapper
   */
  const updateLeafletWrapper = (wrapper, leafletMethod) =>
    (wrapper.wrapped.value = leafletMethod);

  const WINDOW_OR_GLOBAL =
    (typeof self === "object" && self.self === self && self) ||
    (typeof global === "object" && global.global === global && global) ||
    undefined;

  const GLOBAL_LEAFLET_OPT = "useGlobalLeaflet";

  const componentProps = {
    options: {
      type: Object,
      default: () => ({}),
      custom: true,
    },
  };

  const setupComponent = (props) => {
    return { options: props.options, methods: {} };
  };

  const layerProps = {
    ...componentProps,
    pane: {
      type: String,
    },
    attribution: {
      type: String,
    },
    name: {
      type: String,
      custom: true,
    },
    layerType: {
      type: String,
      custom: true,
    },
    visible: {
      type: Boolean,
      custom: true,
      default: true,
    },
  };

  const setupLayer = (props, leafletRef, context) => {
    const addLayer = vue.inject("addLayer");
    const removeLayer = vue.inject("removeLayer");
    const {
      options: componentOptions,
      methods: componentMethods,
    } = setupComponent(props);

    const options = propsToLeafletOptions(props, layerProps, componentOptions);

    const addThisLayer = () => addLayer({ leafletObject: leafletRef.value });
    const removeThisLayer = () =>
      removeLayer({ leafletObject: leafletRef.value });

    const methods = {
      ...componentMethods,
      setAttribution(val, old) {
        const attributionControl = this.$parent.leafletObject.attributionControl;
        attributionControl.removeAttribution(old).addAttribution(val);
      },
      setName() {
        removeThisLayer();
        if (props.visible) {
          addThisLayer();
        }
      },
      setLayerType() {
        removeThisLayer();
        if (props.visible) {
          addThisLayer();
        }
      },
      setVisible(isVisible) {
        if (leafletRef.value) {
          if (isVisible) {
            addThisLayer();
          } else {
            removeThisLayer();
          }
        }
      },
      bindPopup({ leafletObject }) {
        if (!leafletRef.value || !isFunction(leafletRef.value.bindPopup)) {
          console.warn(
            "Attempt to bind popup before bindPopup method available on layer."
          );

          return;
        }

        leafletRef.value.bindPopup(leafletObject);
      },
      bindTooltip({ leafletObject }) {
        if (!leafletRef.value || !isFunction(leafletRef.value.bindTooltip)) {
          console.warn(
            "Attempt to bind tooltip before bindTooltip method available on layer."
          );

          return;
        }

        leafletRef.value.bindTooltip(leafletObject);
      },
      unbindTooltip() {
        const tooltip =
          leafletRef.value && isFunction(leafletRef.value.getTooltip)
            ? leafletRef.value.getTooltip()
            : null;
        if (tooltip && isFunction(tooltip.unbindTooltip)) {
          tooltip.unbindTooltip();
        }
      },
      unbindPopup() {
        const popup =
          leafletRef.value && isFunction(leafletRef.value.getPopup)
            ? leafletRef.value.getPopup()
            : null;
        if (popup && isFunction(popup.unbindPopup)) {
          popup.unbindPopup();
        }
      },
      updateVisibleProp(value) {
        /**
         * Triggers when the visible prop needs to be updated
         * @type {boolean}
         * @property {boolean} value - value of the visible property
         */
        context.emit("update:visible", value);
      },
    };

    vue.provide("bindPopup", methods.bindPopup);
    vue.provide("bindTooltip", methods.bindTooltip);
    vue.provide("unbindTooltip", methods.unbindTooltip);
    vue.provide("unbindPopup", methods.unbindPopup);

    vue.onUnmounted(() => {
      methods.unbindPopup();
      methods.unbindTooltip();
      removeThisLayer();
    });

    return { options, methods };
  };

  const render = (ready, slots) => {
    if (ready && slots.default) {
      return vue.h("div", { style: { display: "none" } }, slots.default());
    }
  };

  const interactiveLayerProps = {
    ...layerProps,
    interactive: {
      type: Boolean,
      default: undefined,
    },
    bubblingMouseEvents: {
      type: Boolean,
      default: undefined,
    },
  };

  const setupInteractiveLayer = (props, leafletRef, context) => {
    const { options: layerOptions, methods } = setupLayer(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(
      props,
      interactiveLayerProps,
      layerOptions
    );

    return { options, methods };
  };

  const pathProps = {
    ...interactiveLayerProps,
    stroke: {
      type: Boolean,
      default: undefined,
    },
    color: {
      type: String,
    },
    weight: {
      type: Number,
    },
    opacity: {
      type: Number,
    },
    lineCap: {
      type: String,
    },
    lineJoin: {
      type: String,
    },
    dashArray: {
      type: String,
    },
    dashOffset: {
      type: String,
    },
    fill: {
      type: Boolean,
      default: undefined,
    },
    fillColor: {
      type: String,
    },
    fillOpacity: {
      type: Number,
    },
    fillRule: {
      type: String,
    },
    className: {
      type: String,
    },
  };

  const setupPath = (props, leafletRef, context) => {
    const {
      options: interactiveLayerOptions,
      methods: interactiveLayerMethods,
    } = setupInteractiveLayer(props, leafletRef, context);

    const options = propsToLeafletOptions(
      props,
      pathProps,
      interactiveLayerOptions
    );

    const removeLayer = vue.inject("removeLayer");
    const methods = {
      ...interactiveLayerMethods,
      setStroke(stroke) {
        leafletRef.value.setStyle({ stroke });
      },
      setColor(color) {
        leafletRef.value.setStyle({ color });
      },
      setWeight(weight) {
        leafletRef.value.setStyle({ weight });
      },
      setOpacity(opacity) {
        leafletRef.value.setStyle({ opacity });
      },
      setLineCap(lineCap) {
        leafletRef.value.setStyle({ lineCap });
      },
      setLineJoin(lineJoin) {
        leafletRef.value.setStyle({ lineJoin });
      },
      setDashArray(dashArray) {
        leafletRef.value.setStyle({ dashArray });
      },
      setDashOffset(dashOffset) {
        leafletRef.value.setStyle({ dashOffset });
      },
      setFill(fill) {
        leafletRef.value.setStyle({ fill });
      },
      setFillColor(fillColor) {
        leafletRef.value.setStyle({ fillColor });
      },
      setFillOpacity(fillOpacity) {
        leafletRef.value.setStyle({ fillOpacity });
      },
      setFillRule(fillRule) {
        leafletRef.value.setStyle({ fillRule });
      },
      setClassName(className) {
        leafletRef.value.setStyle({ className });
      },
    };

    vue.onBeforeUnmount(() => {
      removeLayer({ leafletObject: leafletRef.value });
    });

    return { options, methods };
  };

  const circleMarkerProps = {
    ...pathProps,
    /**
     * Radius of the marker in pixels.
     */
    radius: {
      type: Number,
    },
    latLng: {
      type: [Object, Array],
      required: true,
      custom: true,
    },
  };

  const setupCircleMarker = (props, leafletRef, context) => {
    const { options: pathOptions, methods: pathMethods } = setupPath(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(props, circleMarkerProps, pathOptions);

    const methods = {
      ...pathMethods,
      setRadius(radius) {
        leafletRef.value.setRadius(radius);
      },
      setLatLng(latLng) {
        leafletRef.value.setLatLng(latLng);
      },
    };

    return { options, methods };
  };

  const circleProps = {
    ...circleMarkerProps,
    /**
     * Radius of the circle in meters.
     */
    radius: {
      type: Number,
    },
  };

  const setupCircle = (props, leafletRef, context) => {
    const {
      options: circleMarkerOptions,
      methods: circleMarkerMethods,
    } = setupCircleMarker(props, leafletRef, context);

    const options = propsToLeafletOptions(
      props,
      circleProps,
      circleMarkerOptions
    );

    const methods = {
      ...circleMarkerMethods,
    };

    return { options, methods };
  };

  /**
   * Circle component, lets you add and personalize circles on the map
   */
  var script = {
    name: "LCircle",
    props: circleProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setupCircle(props, leafletRef, context);

      vue.onMounted(async () => {
        const { circle, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = circle(props.latLng, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);

        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script.__file = "src/components/LCircle.vue";

  /**
   * Circle Marker component, lets you add and personalize circle markers on the map
   */
  var script$1 = {
    name: "LCircleMarker",
    props: circleMarkerProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setupCircleMarker(props, leafletRef, context);

      vue.onMounted(async () => {
        const { circleMarker, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = circleMarker(props.latLng, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);

        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script$1.__file = "src/components/LCircleMarker.vue";

  const controlProps = {
    ...componentProps,
    position: {
      type: String,
    },
  };

  const setupControl = (props, leafletRef) => {
    const {
      options: componentOptions,
      methods: componentMethods,
    } = setupComponent(props);

    const options = propsToLeafletOptions(props, controlProps, componentOptions);

    const methods = {
      ...componentMethods,
      setPosition(position) {
        if (leafletRef.value) {
          leafletRef.value.setPosition(position);
        }
      },
    };

    vue.onUnmounted(() => {
      if (leafletRef.value) {
        leafletRef.value.remove();
      }
    });

    return { options, methods };
  };

  const render$1 = (slots) => {
    if (slots.default) {
      return vue.h("div", { ref: "root" }, slots.default());
    }

    return null;
  };

  var script$2 = {
    name: "LControl",
    props: {
      ...controlProps,
      disableClickPropagation: {
        type: Boolean,
        custom: true,
        default: true,
      },
      disableScrollPropagation: {
        type: Boolean,
        custom: true,
        default: false,
      },
    },
    setup(props, context) {
      const leafletRef = vue.ref({});
      const root = vue.ref(null);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const registerControl = vue.inject("registerControl");

      const { options, methods } = setupControl(props, leafletRef);

      vue.onMounted(async () => {
        const { Control, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        const LControl = Control.extend({
          onAdd() {
            return root.value;
          },
        });

        leafletRef.value = new LControl(options);
        propsBinder(methods, leafletRef.value, props);
        registerControl({ leafletObject: leafletRef.value });

        if (props.disableClickPropagation) {
          DomEvent.disableClickPropagation(root.value);
        }
        if (props.disableScrollPropagation) {
          DomEvent.disableScrollPropagation(root.value);
        }
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { root, leafletObject: leafletRef };
    },
    render() {
      return render$1(this.$slots);
    },
  };

  script$2.__file = "src/components/LControl.vue";

  const controlAttributionProps = {
    ...controlProps,
    prefix: {
      type: String,
    },
  };

  const setupControlAttribution = (props, leafletRef) => {
    const { options: controlOptions, methods: controlMethods } = setupControl(
      props,
      leafletRef
    );

    const options = propsToLeafletOptions(
      props,
      controlAttributionProps,
      controlOptions
    );

    const methods = {
      ...controlMethods,
      setPrefix(prefix) {
        leafletRef.value.setPrefix(prefix);
      },
    };

    return { options, methods };
  };

  var script$3 = {
    name: "LControlAttribution",
    props: controlAttributionProps,
    setup(props, context) {
      const leafletRef = vue.ref({});

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const registerControl = vue.inject("registerControl");

      const { options, methods } = setupControlAttribution(props, leafletRef);

      vue.onMounted(async () => {
        const { control } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = control.attribution(options);
        propsBinder(methods, leafletRef.value, props);
        registerControl({ leafletObject: leafletRef.value });
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { leafletObject: leafletRef.value };
    },
    render() {
      return null;
    },
  };

  script$3.__file = "src/components/LControlAttribution.vue";

  const controlLayersProps = {
    ...controlProps,
    collapsed: {
      type: Boolean,
      default: undefined,
    },
    autoZIndex: {
      type: Boolean,
      default: undefined,
    },
    hideSingleBase: {
      type: Boolean,
      default: undefined,
    },
    sortLayers: {
      type: Boolean,
      default: undefined,
    },
    sortFunction: {
      type: Function,
    },
  };

  const setupControlLayers = (props, leafletRef) => {
    const { options: controlOptions } = setupControl(props, leafletRef);

    const options = propsToLeafletOptions(
      props,
      controlLayersProps,
      controlOptions
    );

    const methods = {
      addLayer(layer) {
        if (layer.layerType === "base") {
          leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);
        } else if (layer.layerType === "overlay") {
          leafletRef.value.addOverlay(layer.leafletObject, layer.name);
        }
      },
      removeLayer(layer) {
        leafletRef.value.removeLayer(layer.leafletObject);
      },
    };

    return { options, methods };
  };

  var script$4 = {
    name: "LControlLayers",
    props: controlLayersProps,
    setup(props, context) {
      const leafletRef = vue.ref({});

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const registerLayerControl = vue.inject("registerLayerControl");

      const { options, methods } = setupControlLayers(props, leafletRef);

      vue.onMounted(async () => {
        const { control } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = control.layers(null, null, options);

        propsBinder(methods, leafletRef.value, props);

        registerLayerControl({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { leafletObject: leafletRef.value };
    },
    render() {
      return null;
    },
  };

  script$4.__file = "src/components/LControlLayers.vue";

  const controlScaleProps = {
    ...controlProps,
    maxWidth: {
      type: Number,
    },
    metric: {
      type: Boolean,
      default: undefined,
    },
    imperial: {
      type: Boolean,
      default: undefined,
    },
    updateWhenIdle: {
      type: Boolean,
      default: undefined,
    },
  };

  const setupControlScale = (props, leafletRef) => {
    const { options: controlOptions, methods: controlMethods } = setupControl(
      props,
      leafletRef
    );

    const options = propsToLeafletOptions(
      props,
      controlScaleProps,
      controlOptions
    );

    return { options, methods: controlMethods };
  };

  var script$5 = {
    name: "LControlScale",
    props: controlScaleProps,
    setup(props, context) {
      const leafletRef = vue.ref({});

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const registerControl = vue.inject("registerControl");

      const { options, methods } = setupControlScale(props, leafletRef);

      vue.onMounted(async () => {
        const { control } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = control.scale(options);
        propsBinder(methods, leafletRef.value, props);
        registerControl({ leafletObject: leafletRef.value });
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { leafletObject: leafletRef.value };
    },
    render() {
      return null;
    },
  };

  script$5.__file = "src/components/LControlScale.vue";

  const controlZoomProps = {
    ...controlProps,
    zoomInText: {
      type: String,
    },
    zoomInTitle: {
      type: String,
    },
    zoomOutText: {
      type: String,
    },
    zoomOutTitle: {
      type: String,
    },
  };

  const setupControlZoom = (props, leafletRef) => {
    const { options: controlOptions, methods: controlMethods } = setupControl(
      props,
      leafletRef
    );

    const options = propsToLeafletOptions(
      props,
      controlZoomProps,
      controlOptions
    );

    return { options, methods: controlMethods };
  };

  var script$6 = {
    name: "LControlZoom",
    props: controlZoomProps,
    setup(props, context) {
      const leafletRef = vue.ref({});

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const registerControl = vue.inject("registerControl");

      const { options, methods } = setupControlZoom(props, leafletRef);

      vue.onMounted(async () => {
        const { control } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = control.zoom(options);
        propsBinder(methods, leafletRef.value, props);
        registerControl({ leafletObject: leafletRef.value });
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { leafletObject: leafletRef.value };
    },
    render() {
      return null;
    },
  };

  script$6.__file = "src/components/LControlZoom.vue";

  const layerGroupProps = {
    ...layerProps,
  };

  const setupLayerGroup = (props, leafletRef, context) => {
    const { options: layerOptions, methods: layerMethods } = setupLayer(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(props, layerGroupProps, layerOptions);

    const methods = {
      ...layerMethods,
      addLayer(layer) {
        leafletRef.value.addLayer(layer.leafletObject);
      },
      removeLayer(layer) {
        leafletRef.value.removeLayer(layer.leafletObject);
      },
    };

    vue.provide("addLayer", methods.addLayer);
    vue.provide("removeLayer", methods.removeLayer);

    return { options, methods };
  };

  const featureGroupProps = {
    ...layerGroupProps,
  };

  const setupFeatureGroup = (props, leafletRef) => {
    const { options: layerOptions, methods: layerGroupMethods } = setupLayerGroup(
      props,
      leafletRef
    );

    const options = propsToLeafletOptions(props, featureGroupProps, layerOptions);

    const methods = {
      ...layerGroupMethods,
    };

    return { options, methods };
  };

  var script$7 = {
    props: featureGroupProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { methods, options } = setupFeatureGroup(props, leafletRef);

      vue.onMounted(async () => {
        const { featureGroup, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = featureGroup(options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script$7.__file = "src/components/LFeatureGroup.vue";

  const geoJSONProps = {
    ...layerGroupProps,
    geojson: {
      type: [Object, Array],
      custom: true,
    },
  };

  const setupGeoJSON = (props, leafletRef, context) => {
    const { options: layerOptions, methods: layerGroupMethods } = setupLayerGroup(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(props, geoJSONProps, layerOptions);

    const methods = {
      ...layerGroupMethods,
      setGeojson(newVal) {
        leafletRef.value.clearLayers();
        leafletRef.value.addData(newVal);
      },
      getGeoJSONData() {
        return leafletRef.value.toGeoJSON();
      },
      getBounds() {
        return leafletRef.value.getBounds();
      },
    };

    return { options, methods };
  };

  var script$8 = {
    props: geoJSONProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { methods, options } = setupGeoJSON(props, leafletRef, context);

      vue.onMounted(async () => {
        const { geoJSON, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = geoJSON(props.geojson, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script$8.__file = "src/components/LGeoJson.vue";

  const gridLayerProps = {
    ...layerProps,
    opacity: {
      type: Number,
    },
    zIndex: {
      type: Number,
    },
    tileSize: {
      type: Number,
    },
    noWrap: {
      type: Boolean,
      default: undefined,
    },
    minZoom: {
      type: Number,
    },
    maxZoom: {
      type: Number,
    },
  };

  const setupGridLayer = (props, leafletRef, context) => {
    const { options: layerOptions, methods: layerMethods } = setupLayer(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(props, gridLayerProps, layerOptions);

    return { options, methods: { ...layerMethods } };
  };

  var script$9 = {
    props: {
      ...gridLayerProps,
      childRender: {
        type: Function,
        required: true,
      },
    },
    setup(props, context) {
      const leafletRef = vue.ref({});
      const tileComponents = vue.ref({});
      const root = vue.ref(null);
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setupGridLayer(props, leafletRef, context);

      vue.onMounted(async () => {
        const { GridLayer, DomEvent, DomUtil } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        methods.onUnload = (e) => {
          const key = leafletRef.value._tileCoordsToKey(e.coords);
          if (tileComponents[key]) {
            tileComponents[key].innerHTML = "";
            tileComponents[key] = undefined;
          }
        };

        methods.setTileComponent = () => {
          leafletRef.value.redraw();
        };

        const GLayer = GridLayer.extend({
          createTile(coords) {
            const key = leafletRef.value._tileCoordsToKey(coords);
            tileComponents[key] = DomUtil.create("div");

            let vNode = vue.h(
              { setup: props.childRender, props: ["coords"] },
              { coords }
            );
            vue.render(vNode, tileComponents[key]);

            return tileComponents[key];
          },
        });

        leafletRef.value = new GLayer(options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        leafletRef.value.on("tileunload", methods.onUnload);

        propsBinder(methods, leafletRef.value, props);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });

      vue.onUnmounted(() => {
        leafletRef.value.off("tileunload", methods.onUnload);
      });

      return { root, ready, leafletObject: leafletRef };
    },
    render() {
      if (this.ready) {
        return vue.h("div", { style: { display: "none" }, ref: "root" });
      }
      return null;
    },
  };

  script$9.__file = "src/components/LGridLayer.vue";

  const iconProps = {
    iconUrl: {
      type: String,
    },
    iconRetinaUrl: {
      type: String,
    },
    iconSize: {
      type: [Object, Array],
    },
    iconAnchor: {
      type: [Object, Array],
    },
    popupAnchor: {
      type: [Object, Array],
    },
    tooltipAnchor: {
      type: [Object, Array],
    },
    shadowUrl: {
      type: String,
    },
    shadowRetinaUrl: {
      type: String,
    },
    shadowSize: {
      type: [Object, Array],
    },
    shadowAnchor: {
      type: [Object, Array],
    },
    bgPos: {
      type: [Object, Array],
    },
    className: {
      type: String,
    },
  };

  /**
   * Icon component, lets you add and custom icons to the map
   */
  var script$a = {
    name: "LIcon",
    props: {
      ...iconProps,
      ...componentProps,
    },
    setup(props, context) {
      const root = vue.ref(null);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const canSetParentHtml = vue.inject("canSetParentHtml");
      const setParentHtml = vue.inject("setParentHtml");
      const setIcon = vue.inject("setIcon");

      let onDomEvent;
      let offDomEvent;
      let divIcon;
      let icon;
      let iconObject = undefined;

      const createIcon = (el, recreationNeeded, htmlSwapNeeded) => {
        const elHtml = el && el.innerHTML;
        if (!recreationNeeded) {
          if (htmlSwapNeeded && iconObject && canSetParentHtml()) {
            setParentHtml(elHtml);
          }
          return;
        }

        const listeners = remapEvents(context.attrs);
        if (iconObject) {
          offDomEvent(iconObject, listeners);
        }

        const { options: componentOptions } = setupComponent(props);
        const options = propsToLeafletOptions(props, iconProps, componentOptions);
        if (elHtml) {
          options.html = elHtml;
        }

        iconObject = options.html ? divIcon(options) : icon(options);
        onDomEvent(iconObject, listeners);
        setIcon(iconObject);
      };

      const scheduleCreateIcon = () => {
        vue.nextTick(() => createIcon(root.value, true, false));
      };

      const scheduleHtmlSwap = () => {
        vue.nextTick(() => createIcon(root.value, false, true));
      };

      const methods = {
        setIconUrl: scheduleCreateIcon,
        setIconRetinaUrl: scheduleCreateIcon,
        setIconSize: scheduleCreateIcon,
        setIconAnchor: scheduleCreateIcon,
        setPopupAnchor: scheduleCreateIcon,
        setTooltipAnchor: scheduleCreateIcon,
        setShadowUrl: scheduleCreateIcon,
        setShadowRetinaUrl: scheduleCreateIcon,
        setShadowAnchor: scheduleCreateIcon,
        setBgPos: scheduleCreateIcon,
        setClassName: scheduleCreateIcon,
        setHtml: scheduleCreateIcon,
      };

      vue.onMounted(async () => {
        const { DomEvent, divIcon: lDivIcon, icon: lIcon } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        onDomEvent = DomEvent.on;
        offDomEvent = DomEvent.off;
        divIcon = lDivIcon;
        icon = lIcon;

        propsBinder(methods, {}, props);

        const observer = new MutationObserver(scheduleHtmlSwap);
        observer.observe(root.value, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true,
        });
        scheduleCreateIcon();
      });

      return { root };
    },
    render() {
      const content = this.$slots.default ? this.$slots.default() : undefined;
      return vue.h("div", { ref: "root" }, content);
    },
  };

  script$a.__file = "src/components/LIcon.vue";

  /**
   * @typedef {import('leaflet/dist/leaflet-src.esm.js').LatLngBounds} LatLngBounds
   */

  const imageOverlayProps = {
    ...layerProps,
    opacity: {
      type: Number,
    },
    alt: {
      type: String,
    },
    interactive: {
      type: Boolean,
      default: undefined,
    },
    crossOrigin: {
      type: Boolean,
      default: undefined,
    },
    errorOverlayUrl: {
      type: String,
    },
    zIndex: {
      type: Number,
    },
    className: {
      type: String,
    },
    url: {
      type: String,
      required: true,
      custom: true,
    },
    bounds: {
      type: [Array, Object],
      required: true,
      custom: true,
    },
  };

  const setupImageOverlay = (props, leafletRef, context) => {
    const { options: layerOptions, methods: layerMethods } = setupLayer(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(props, imageOverlayProps, layerOptions);

    const methods = {
      ...layerMethods,
      /**
       * Sets the opacity of the overlay.
       * @param {number} opacity
       */
      setOpacity(opacity) {
        return leafletRef.value.setOpacity(opacity);
      },
      /**
       * Changes the URL of the image.
       * @param {string} url
       */
      setUrl(url) {
        return leafletRef.value.setUrl(url);
      },
      /**
       * Update the bounds that this ImageOverlay covers
       * @param {LatLngBounds | Array<Array<number>>} bounds
       */
      setBounds(bounds) {
        return leafletRef.value.setBounds(bounds);
      },
      /**
       * Get the bounds that this ImageOverlay covers
       * @returns {LatLngBounds}
       */
      getBounds() {
        return leafletRef.value.getBounds();
      },
      /**
       * Returns the instance of HTMLImageElement used by this overlay.
       * @returns {HTMLElement}
       */
      getElement() {
        return leafletRef.value.getElement();
      },
      /**
       * Brings the layer to the top of all overlays.
       */
      bringToFront() {
        return leafletRef.value.bringToFront();
      },
      /**
       * Brings the layer to the bottom of all overlays.
       */
      bringToBack() {
        return leafletRef.value.bringToBack();
      },
      /**
       * Changes the zIndex of the image overlay.
       * @param {number} zIndex
       */
      setZIndex(zIndex) {
        return leafletRef.value.setZIndex(zIndex);
      },
    };

    return { options, methods };
  };

  /**
   * ImageOverlay component, render a plain image instead of a geospatial map.
   */
  var script$b = {
    name: "LImageOverlay",
    props: imageOverlayProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setupImageOverlay(props, leafletRef, context);

      vue.onMounted(async () => {
        const { imageOverlay, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');
        leafletRef.value = imageOverlay(props.url, props.bounds, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);
        propsBinder(methods, leafletRef.value, props);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });

      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script$b.__file = "src/components/LImageOverlay.vue";

  var script$c = {
    props: layerGroupProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { methods } = setupLayerGroup(props, leafletRef, context);

      vue.onMounted(async () => {
        const { layerGroup, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');
        leafletRef.value = layerGroup(props.options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script$c.__file = "src/components/LLayerGroup.vue";

  const mapProps = {
    ...componentProps,
    /**
     * The center of the map, supports .sync modifier
     */
    center: {
      type: [Object, Array],
    },
    /**
     * The bounds of the map, supports .sync modifier
     */
    bounds: {
      type: [Array, Object],
    },
    /**
     * The max bounds of the map
     */
    maxBounds: {
      type: [Array, Object],
    },
    /**
     * The zoom of the map, supports .sync modifier
     */
    zoom: {
      type: Number,
    },
    /**
     * The minZoom of the map
     */
    minZoom: {
      type: Number,
    },
    /**
     * The maxZoom of the map
     */
    maxZoom: {
      type: Number,
    },
    /**
     * The paddingBottomRight of the map
     */
    paddingBottomRight: {
      type: Array,
    },
    /**
     * The paddingTopLeft of the map
     */
    paddingTopLeft: {
      type: Array,
    },
    /**
     * The padding of the map
     */
    padding: {
      type: Array,
    },
    /**
     * The worldCopyJump option for the map
     */
    worldCopyJump: {
      type: Boolean,
      default: undefined,
    },
    /**
     * The CRS to use for the map. Can be an object that defines a coordinate reference
     * system for projecting geographical points into screen coordinates and back
     * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string
     * name identifying one of Leaflet's defined CRSs, such as "EPSG4326".
     */
    crs: {
      type: [String, Object],
    },
    maxBoundsViscosity: {
      type: Number,
    },
    inertia: {
      type: Boolean,
      default: undefined,
    },
    inertiaDeceleration: {
      type: Number,
    },
    inertiaMaxSpeed: {
      type: Number,
    },
    easeLinearity: {
      type: Number,
    },
    zoomAnimation: {
      type: Boolean,
      default: undefined,
    },
    zoomAnimationThreshold: {
      type: Number,
    },
    fadeAnimation: {
      type: Boolean,
      default: undefined,
    },
    markerZoomAnimation: {
      type: Boolean,
      default: undefined,
    },
    noBlockingAnimations: {
      type: Boolean,
      default: undefined,
    },
    useGlobalLeaflet: {
      type: Boolean,
      default: undefined,
    },
  };

  var script$d = {
    emits: ["ready", "update:zoom", "update:center", "update:bounds"],
    props: mapProps,
    setup(props, context) {
      const root = vue.ref(null);
      const blueprint = vue.reactive({
        ready: false,
        leafletRef: {},
        layersToAdd: [],
        layersInControl: [],
      });

      const { options: componentOptions } = setupComponent(props);

      const options = propsToLeafletOptions(props, mapProps, componentOptions);

      const addLayer = provideLeafletWrapper("addLayer");
      const removeLayer = provideLeafletWrapper("removeLayer");
      const registerControl = provideLeafletWrapper("registerControl");
      const registerLayerControl = provideLeafletWrapper("registerLayerControl");
      vue.provide(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);

      const eventHandlers = {
        moveEndHandler() {
          /**
           * Triggers when zoom is updated
           * @type {number,string}
           */
          context.emit("update:zoom", blueprint.leafletRef.getZoom());
          /**
           * Triggers when center is updated
           * @type {object,array}
           */
          context.emit("update:center", blueprint.leafletRef.getCenter());

          /**
           * Triggers when bounds are updated
           * @type {object}
           */
          context.emit("update:bounds", blueprint.leafletRef.getBounds());
        },
        overlayAddHandler(e) {
          const layer = blueprint.layersInControl.find((l) => l.name === e.name);
          if (layer) {
            layer.updateVisibleProp(true);
          }
        },
        overlayRemoveHandler(e) {
          const layer = blueprint.layersInControl.find((l) => l.name === e.name);
          if (layer) {
            layer.updateVisibleProp(false);
          }
        },
      };

      vue.onMounted(async () => {
        if (props.useGlobalLeaflet) {
          WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await import('leaflet'));
        }
        const {
          map,
          CRS,
          Icon,
          latLngBounds,
          latLng,
          DomEvent,
        } = props.useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        try {
          options.beforeMapMount && (await options.beforeMapMount());
        } catch (error) {
          console.error(
            `The following error occurred running the provided beforeMapMount hook ${error.message}`
          );
        }

        await resetWebpackIcon(Icon);

        const optionsCrs =
          typeof options.crs == "string" ? CRS[options.crs] : options.crs;
        options.crs = optionsCrs || CRS.EPSG3857;

        const methods = {
          addLayer(layer) {
            if (layer.layerType !== undefined) {
              if (blueprint.layerControl === undefined) {
                blueprint.layersToAdd.push(layer);
              } else {
                const exist = blueprint.layersInControl.find(
                  (l) =>
                    l.leafletObject._leaflet_id ===
                    layer.leafletObject._leaflet_id
                );
                if (!exist) {
                  blueprint.layerControl.addLayer(layer);
                  blueprint.layersInControl.push(layer);
                }
              }
            }
            if (layer.visible !== false) {
              blueprint.leafletRef.addLayer(layer.leafletObject);
            }
          },
          removeLayer(layer) {
            if (layer.layerType !== undefined) {
              if (blueprint.layerControl === undefined) {
                blueprint.layersToAdd = blueprint.layersToAdd.filter(
                  (l) => l.name !== layer.name
                );
              } else {
                blueprint.layerControl.removeLayer(layer.leafletObject);
                blueprint.layersInControl = blueprint.layersInControl.filter(
                  (l) =>
                    l.leafletObject._leaflet_id !==
                    layer.leafletObject._leaflet_id
                );
              }
            }
            blueprint.leafletRef.removeLayer(layer.leafletObject);
          },

          registerLayerControl(lControlLayer) {
            blueprint.layerControl = lControlLayer;
            blueprint.layersToAdd.forEach((layer) => {
              blueprint.layerControl.addLayer(layer);
            });
            blueprint.layersToAdd = [];

            registerControl(lControlLayer);
          },

          registerControl(lControl) {
            blueprint.leafletRef.addControl(lControl.leafletObject);
          },

          setZoom(newVal) {
            const zoom = blueprint.leafletRef.getZoom();
            if (newVal !== zoom) {
              blueprint.leafletRef.setZoom(newVal, {
                animate: props.noBlockingAnimations ? false : null,
              });
            }
          },

          setPaddingBottomRight(newVal) {
            blueprint.paddingBottomRight = newVal;
          },
          setPaddingTopLeft(newVal) {
            blueprint.paddingTopLeft = newVal;
          },
          setPadding(newVal) {
            blueprint.padding = newVal;
          },
          setCrs(newVal) {
            const prevBounds = blueprint.leafletRef.getBounds();
            blueprint.leafletRef.options.crs = newVal;
            blueprint.leafletRef.fitBounds(prevBounds, {
              animate: false,
              padding: [0, 0],
            });
          },
          fitBounds(bounds) {
            blueprint.leafletRef.fitBounds(bounds, {
              animate: this.noBlockingAnimations ? false : null,
            });
          },
          setBounds(newVal) {
            if (!newVal) {
              return;
            }
            const newBounds = latLngBounds(newVal);
            if (!newBounds.isValid()) {
              return;
            }
            const oldBounds =
              blueprint.lastSetBounds || blueprint.leafletRef.getBounds();
            const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals
            if (boundsChanged) {
              blueprint.lastSetBounds = newBounds;
              blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);
            }
          },

          setCenter(newVal) {
            if (newVal == null) {
              return;
            }
            const newCenter = latLng(newVal);
            const oldCenter =
              blueprint.lastSetCenter || blueprint.leafletRef.getCenter();
            if (
              oldCenter.lat !== newCenter.lat ||
              oldCenter.lng !== newCenter.lng
            ) {
              blueprint.lastSetCenter = newCenter;
              blueprint.leafletRef.panTo(newCenter, {
                animate: this.noBlockingAnimations ? false : null,
              });
            }
          },
        };

        updateLeafletWrapper(addLayer, methods.addLayer);
        updateLeafletWrapper(removeLayer, methods.removeLayer);
        updateLeafletWrapper(registerControl, methods.registerControl);
        updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);

        blueprint.leafletRef = map(root.value, options);

        propsBinder(methods, blueprint.leafletRef, props);
        const listeners = remapEvents(context.attrs);

        blueprint.leafletRef.on(
          "moveend",
          debounce(eventHandlers.moveEndHandler, 100)
        );
        blueprint.leafletRef.on("overlayadd", eventHandlers.overlayAddHandler);
        blueprint.leafletRef.on(
          "overlayremove",
          eventHandlers.overlayRemoveHandler
        );
        DomEvent.on(blueprint.leafletRef, listeners);
        blueprint.ready = true;
        vue.nextTick(() => context.emit("ready", blueprint.leafletRef));
      });

      vue.onBeforeUnmount(() => {
        if (blueprint.leafletRef) {
          blueprint.leafletRef.off();
          blueprint.leafletRef.remove();
        }
      });

      const leafletObject = vue.computed(() => blueprint.leafletRef);
      const ready = vue.computed(() => blueprint.ready);
      return { root, ready, leafletObject };
    },
    render() {
      return vue.h(
        "div",
        { style: { width: "100%", height: "100%" }, ref: "root" },
        this.ready ? this.$slots.default() : {}
      );
    },
  };

  script$d.__file = "src/components/LMap.vue";

  const markerProps = {
    ...layerProps,
    draggable: {
      type: Boolean,
      default: undefined,
    },
    icon: {
      type: [Object],
    },
    zIndexOffset: {
      type: Number,
    },
    latLng: {
      type: [Object, Array],
      custom: true,
      required: true,
    },
  };

  const setupMarker = (props, leafletRef, context) => {
    const { options: layerOptions, methods: layerMethods } = setupLayer(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(props, markerProps, layerOptions);

    const methods = {
      ...layerMethods,
      setDraggable(value) {
        if (leafletRef.value.dragging) {
          value
            ? leafletRef.value.dragging.enable()
            : leafletRef.value.dragging.disable();
        }
      },
      latLngSync(event) {
        context.emit("update:latLng", event.latlng);
        context.emit("update:lat-lng", event.latlng);
      },
      setLatLng(newVal) {
        if (newVal == null) {
          return;
        }

        if (leafletRef.value) {
          const oldLatLng = leafletRef.value.getLatLng();
          if (!oldLatLng || !oldLatLng.equals(newVal)) {
            leafletRef.value.setLatLng(newVal);
          }
        }
      },
    };

    return { options, methods };
  };

  /**
   * Marker component, lets you add and personalize markers on the map
   */
  var script$e = {
    name: "LMarker",
    props: markerProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      vue.provide("canSetParentHtml", () => !!leafletRef.value.getElement());
      vue.provide(
        "setParentHtml",
        (html) => (leafletRef.value.getElement().innerHTML = html)
      );
      vue.provide(
        "setIcon",
        (newIcon) => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon)
      );
      const { options, methods } = setupMarker(props, leafletRef, context);
      if (options.icon === undefined) {
        // If the options object has a property named 'icon', then Leaflet will overwrite
        // the default icon with it for the marker, _even if it is undefined_.
        // This leads to the issue discussed in https://github.com/vue-leaflet/vue-leaflet/issues/130
        delete options.icon;
      }

      vue.onMounted(async () => {
        const { marker, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');
        leafletRef.value = marker(props.latLng, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        leafletRef.value.on("move", debounce(methods.latLngSync, 100));
        propsBinder(methods, leafletRef.value, props);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });

      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script$e.__file = "src/components/LMarker.vue";

  const polylineProps = {
    ...pathProps,
    smoothFactor: {
      type: Number,
    },
    noClip: {
      type: Boolean,
      default: undefined,
    },
    latLngs: {
      type: Array,
      required: true,
      custom: true,
    },
  };

  const setupPolyline = (props, leafletRef, context) => {
    const { options: pathOptions, methods: pathMethods } = setupPath(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(props, polylineProps, pathOptions);

    const methods = {
      ...pathMethods,
      setSmoothFactor(smoothFactor) {
        leafletRef.value.setStyle({ smoothFactor });
      },
      setNoClip(noClip) {
        leafletRef.value.setStyle({ noClip });
      },
      addLatLng(latLng) {
        leafletRef.value.addLatLng(latLng);
      },
    };

    return { options, methods };
  };

  const polygonProps = {
    ...polylineProps,
  };

  const setupPolygon = (props, leafletRef, context) => {
    const { options: polylineOptions, methods: polylineMethods } = setupPolyline(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(props, polygonProps, polylineOptions);

    const methods = {
      ...polylineMethods,
      toGeoJSON(precision) {
        return leafletRef.value.toGeoJSON(precision);
      },
    };

    return { options, methods };
  };

  /**
   * Polygon component, lets you add and customize polygon regions on the map
   */
  var script$f = {
    name: "LPolygon",
    props: polygonProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setupPolygon(props, leafletRef, context);

      vue.onMounted(async () => {
        const { polygon, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = polygon(props.latLngs, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);

        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });

      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script$f.__file = "src/components/LPolygon.vue";

  /**
   * Polyline component, lets you add and personalize polylines on the map
   */
  var script$g = {
    name: "LPolyline",
    props: polylineProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setupPolyline(props, leafletRef, context);

      vue.onMounted(async () => {
        const { polyline, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = polyline(props.latLngs, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);

        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script$g.__file = "src/components/LPolyline.vue";

  const popperProps = {
    ...componentProps,
    content: {
      type: String,
      default: null,
    },
  };

  const setupPopper = (props, leafletRef) => {
    const { options, methods: componentMethods } = setupComponent(props);

    const methods = {
      ...componentMethods,
      setContent(newVal) {
        if (leafletRef.value && newVal !== null && newVal !== undefined) {
          leafletRef.value.setContent(newVal);
        }
      },
    };

    return { options, methods };
  };

  const render$2 = (slots) => {
    if (slots.default) {
      return vue.h("div", { ref: "root" }, slots.default());
    }
    return null;
  };

  const popupProps = {
    ...popperProps,
    latLng: {
      type: [Object, Array],
      default: () => [],
    },
  };

  const setupPopup = (props, leafletRef) => {
    const { options, methods } = setupPopper(props, leafletRef);

    const unbindPopup = vue.inject("unbindPopup");

    vue.onBeforeUnmount(() => {
      unbindPopup();
    });

    return { options, methods };
  };

  /**
   * Display a popup on the map
   */
  var script$h = {
    name: "LPopup",
    props: popupProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const root = vue.ref(null);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const bindPopup = vue.inject("bindPopup");

      const { options, methods } = setupPopup(props, leafletRef);

      vue.onMounted(async () => {
        const { popup, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = popup(options);

        if (props.latLng !== undefined) {
          leafletRef.value.setLatLng(props.latLng);
        }

        propsBinder(methods, leafletRef.value, props);
        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);
        leafletRef.value.setContent(props.content || root.value);
        bindPopup({ leafletObject: leafletRef.value });
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { root, leafletObject: leafletRef };
    },
    render() {
      return render$2(this.$slots);
    },
  };

  script$h.__file = "src/components/LPopup.vue";

  polygonProps.latLngs.required = false;
  const rectangleProps = {
    ...polygonProps,
    bounds: {
      type: Array,
      custom: true,
    },
  };

  const setupRectangle = (props, leafletRef, context) => {
    const { options: polygonOptions, methods: polygonMethods } = setupPolygon(
      props,
      leafletRef,
      context
    );

    const options = propsToLeafletOptions(props, rectangleProps, polygonOptions);

    const methods = {
      ...polygonMethods,
      setBounds(latLngBounds) {
        leafletRef.value.setBounds(latLngBounds);
      },
      setLatLngs(latLngs) {
        // Calling setLatLngs on a Leaflet rectangle will convert it
        // to a polygon. So instead, we call setBounds here to ensure
        // that the rectangle remains a rectangle, defined by the
        // bounds of the points in the latLngs array.
        leafletRef.value.setBounds(latLngs);
      },
    };

    return { options, methods };
  };

  /**
   * Rectangle component, lets you add and customize rectangular regions on the map
   */
  var script$i = {
    name: "LRectangle",
    props: rectangleProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setupRectangle(props, leafletRef, context);

      vue.onMounted(async () => {
        const { rectangle, latLngBounds, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        const bounds =
          props.bounds && props.bounds.length
            ? latLngBounds(props.bounds)
            : latLngBounds(props.latLngs);
        leafletRef.value = rectangle(bounds, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);

        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });

      return { ready, leafletObject: leafletRef };
    },
    render() {
      return render(this.ready, this.$slots);
    },
  };

  script$i.__file = "src/components/LRectangle.vue";

  const tileLayerProps = {
    ...gridLayerProps,
    tms: {
      type: Boolean,
      default: undefined,
    },
    subdomains: {
      type: String,
    },
    detectRetina: {
      type: Boolean,
      default: undefined,
    },
    url: {
      type: String,
      required: true,
      custom: true,
    },
  };

  const setupTileLayer = (props, leafletRef, context) => {
    const {
      options: gridLayerOptions,
      methods: gridLayerMethods,
    } = setupGridLayer(props, leafletRef, context);

    const options = propsToLeafletOptions(
      props,
      tileLayerProps,
      gridLayerOptions
    );

    const methods = {
      ...gridLayerMethods,
    };

    return { options, methods };
  };

  var script$j = {
    props: tileLayerProps,
    setup(props, context) {
      const leafletRef = vue.ref({});

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setupTileLayer(props, leafletRef, context);

      vue.onMounted(async () => {
        const { tileLayer, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = tileLayer(props.url, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });

      return { leafletObject: leafletRef };
    },
    render() {
      return null;
    },
  };

  script$j.__file = "src/components/LTileLayer.vue";

  const tooltipProps = {
    ...popperProps,
  };

  const setupTooltip = (props, leafletRef) => {
    const { options, methods } = setupPopper(props, leafletRef);

    const unbindTooltip = vue.inject("unbindTooltip");

    vue.onBeforeUnmount(() => {
      unbindTooltip();
    });

    return { options, methods };
  };

  /**
   * Display a tooltip on the map
   */
  var script$k = {
    name: "LTooltip",
    props: tooltipProps,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const root = vue.ref(null);

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const bindTooltip = vue.inject("bindTooltip");

      const { options, methods } = setupTooltip(props, leafletRef);

      vue.onMounted(async () => {
        const { tooltip, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = tooltip(options);

        propsBinder(methods, leafletRef.value, props);
        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);
        leafletRef.value.setContent(props.content || root.value);
        bindTooltip({ leafletObject: leafletRef.value });
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { root, leafletObject: leafletRef };
    },
    render() {
      return render$2(this.$slots);
    },
  };

  script$k.__file = "src/components/LTooltip.vue";

  const wmsTileLayerProps = {
    ...tileLayerProps,
    layers: {
      type: String,
      required: true,
    },
    styles: {
      type: String,
    },
    format: {
      type: String,
    },
    transparent: {
      type: Boolean,
      default: undefined,
    },
    version: {
      type: String,
    },
    crs: {
      type: Object,
    },
    upperCase: {
      type: Boolean,
      default: undefined,
    },
  };

  const setupWMSTileLayer = (props, leafletRef) => {
    const {
      options: tileLayerOptions,
      methods: tileLayerMethods,
    } = setupTileLayer(props, leafletRef);

    const options = propsToLeafletOptions(
      props,
      wmsTileLayerProps,
      tileLayerOptions
    );

    return {
      options,
      methods: {
        ...tileLayerMethods,
      },
    };
  };

  var script$l = {
    props: wmsTileLayerProps,
    setup(props, context) {
      const leafletRef = vue.ref({});

      const useGlobalLeaflet = vue.inject(GLOBAL_LEAFLET_OPT);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setupWMSTileLayer(props, leafletRef);

      vue.onMounted(async () => {
        const { tileLayer, DomEvent } = useGlobalLeaflet
          ? WINDOW_OR_GLOBAL.L
          : await import('leaflet/dist/leaflet-src.esm');

        leafletRef.value = tileLayer.wms(props.url, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        vue.nextTick(() => context.emit("ready", leafletRef.value));
      });
      return { leafletObject: leafletRef.value };
    },
    render() {
      return null;
    },
  };

  script$l.__file = "src/components/LWmsTileLayer.vue";

  exports.LCircle = script;
  exports.LCircleMarker = script$1;
  exports.LControl = script$2;
  exports.LControlAttribution = script$3;
  exports.LControlLayers = script$4;
  exports.LControlScale = script$5;
  exports.LControlZoom = script$6;
  exports.LFeatureGroup = script$7;
  exports.LGeoJson = script$8;
  exports.LGridLayer = script$9;
  exports.LIcon = script$a;
  exports.LImageOverlay = script$b;
  exports.LLayerGroup = script$c;
  exports.LMap = script$d;
  exports.LMarker = script$e;
  exports.LPolygon = script$f;
  exports.LPolyline = script$g;
  exports.LPopup = script$h;
  exports.LRectangle = script$i;
  exports.LTileLayer = script$j;
  exports.LTooltip = script$k;
  exports.LWmsTileLayer = script$l;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=vue-leaflet.umd.js.map
